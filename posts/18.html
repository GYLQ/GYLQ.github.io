<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script async src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="OTG88475E6" />









  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />


<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">




<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next%20.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="知识拓展," />





  <link rel="alternate" href="/atom.xml" title="孤桜懶契" type="application/atom+xml" />






<meta name="description" content="程序注释​    任何一套程序代码里面实际上都会由大量的程序逻辑所组成，但是如果要想对一套代码进行长期的维护，就需要编写大量的注释，对一些程序的代码功能要进行详细的解释，这样不仅为自己铺平道路，实际上也为后来接手的工程师铺平道路。  关于注释的笑话：有一位程序员到一家新的公司进行项目开发，突然有一天老板说，某一个功能执行的速度实在是太慢了，让这位程序员修改一下，后来这个程序员找到了相关源代码，里面">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVASE">
<meta property="og:url" content="https://gylq.gitee.io/posts/18.html">
<meta property="og:site_name" content="孤桜懶契">
<meta property="og:description" content="程序注释​    任何一套程序代码里面实际上都会由大量的程序逻辑所组成，但是如果要想对一套代码进行长期的维护，就需要编写大量的注释，对一些程序的代码功能要进行详细的解释，这样不仅为自己铺平道路，实际上也为后来接手的工程师铺平道路。  关于注释的笑话：有一位程序员到一家新的公司进行项目开发，突然有一天老板说，某一个功能执行的速度实在是太慢了，让这位程序员修改一下，后来这个程序员找到了相关源代码，里面">
<meta property="article:published_time" content="2020-09-21T01:18:27.429Z">
<meta property="article:modified_time" content="2021-10-20T05:11:07.408Z">
<meta property="article:author" content="孤桜懶契">
<meta property="article:tag" content="知识拓展">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"flipYIn","post_header":"perspectiveRightIn","post_body":"perspectiveLeftIn","coll_header":"swoopIn","sidebar":"shrinkIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://gylq.gitee.io/posts/18.html"/>





<!-- 设置文章需要密码访问 -->
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

  <title>JAVASE | 孤桜懶契</title>
  





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b56c2f3ac99ab0c4efa4cba7755ec64a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>





  
      <!-- 球型气泡标签云 -->
      <script type="text/javascript" src="/js/src/bubble.js"></script>
  

  
      <!-- haoyuePlayer 播放器，移动端大小适配-->
      <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />
  


<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <!--fork me from github-->
    <a href="https://github.com/GYLQ" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">孤桜懶契</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Run</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-导航">
          <a href="/gylq-navigation/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            导航
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-links">
          <a href="/links/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br />
            
            友链
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>






<link href="/css/DPlayer.min.css" rel="stylesheet">
<script src="/js/src/DPlayer.min.js"></script>
<script src="/js/src/hls.min.js"></script>
<script>
    function __create__dps(videos) {
        for (i = 0; i < videos.length; i++) {
            new DPlayer({
                container: document.getElementById('__dp' + i),
                screenshot: true,
                video: {
                    url: videos[i]
                }
            });
        }
        // 修正 Mirages 1.7.10 视频比例错误
        setTimeout(() => {
            let __elementList = document.querySelectorAll('.video-container.video-4-3');
            for (let __element of __elementList) {
                __element.className = 'video-container video-16-9';
                __element.setAttribute('style', 'position: initial;');
            }
        }, 300);
    }
</script>
<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id: "Jo9BKDWYSJy9xykG",ck: "Jo9BKDWYSJy9xykG"})</script> </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
		<div id="container">
		  <div id="content" class="content">
			

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://gylq.gitee.io/posts/18.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="孤桜懶契">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/qq.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孤桜懶契">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JAVASE</h2>
        

        <div class="post-meta">
          <span class="post-time">

             

             

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-21T09:18:27+08:00">
                2020-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/18.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/18.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/18.html" class="leancloud_visitors" data-flag-title="JAVASE">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          <!--
          
          -->

          
            <span class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                <span title="字数">
                  31.8k
                </span>
              

              

              
            </span>
          

          <!-- 隐藏文章内标题下，内容描述
          
          -->

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a><strong>程序注释</strong></h1><p>​    任何一套程序代码里面实际上都会由大量的程序逻辑所组成，但是如果要想对一套代码进行长期的维护，就需要编写大量的注释，对一些程序的代码功能要进行详细的解释，这样不仅为自己铺平道路，实际上也为后来接手的工程师铺平道路。</p>
<blockquote>
<p>关于注释的笑话：有一位程序员到一家新的公司进行项目开发，突然有一天老板说，某一个功能执行的速度实在是太慢了，让这位程序员修改一下，后来这个程序员找到了相关源代码，里面写上了一个注释“后面的兄弟，悠着点，我在这里吗让代码延迟了3秒，别一下子改的太快了，给后面的兄弟留点发挥空间”，于是这位工程师根据前辈的注释进行了修改，将原始的延迟3秒，修改为了延迟2.5秒，速度变快了，老板给了奖金。</p>
</blockquote>
<p>​    在Java程序里面针对于代码的注释一共提供了三种注释形式：</p>
<ul>
<li><p>​        单行注释：“// 注释内容”;（考虑到开发工具的代码格式化问题）</p>
</li>
<li><p>​        多行注释：“/*… 注释内容 … */“;</p>
</li>
<li><p>​        文档注释：“/** … 文档注释的特定语法标记进行注释的编写 …… */”，这种注释往往可以结合开发工具使用</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class YootkDemo&#123; &#x2F;&#x2F; 【单行注释】定义程序的执行主类</span><br><span class="line">	public static void main(String args[])&#123;&#x2F;&#x2F; 【单行注释】程序的执行起点，主方法</span><br><span class="line">		&#x2F;*【多行注释】</span><br><span class="line">			以下的程序代码是在屏幕上进行一些提示信息的输出，如果有需要则可以再里面进行多行的定义	</span><br><span class="line">		*&#x2F;</span><br><span class="line">		System.out.println(&quot;Hello world!&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    既然所有的注释文字不会自己进行代码的编译处理，所以在实际项目开发之中可以将一些暂时不需要的代码通过注释的形式让其失效，这种形式要比直接删除代码更高效。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class YootkDemo&#123; &#x2F;&#x2F; 【单行注释】定义程序的执行主类</span><br><span class="line">	public static void main(String args[])&#123;&#x2F;&#x2F; 【单行注释】程序的执行起点，主方法</span><br><span class="line">		&#x2F;*【多行注释】</span><br><span class="line">			以下的程序代码是在屏幕上进行一些提示信息的输出，如果有需要则可以再里面进行多行的定义	</span><br><span class="line">		*&#x2F;</span><br><span class="line">		System.out.println(&quot;Hello world!&quot;); </span><br><span class="line">		&#x2F;&#x2F; 【代码失效】 System.out.println(&quot;江湖上称我为&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在以后进行项目开发的时候，一些暂时不需要的代码就可以利用注释进行关闭。</p>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>　　<strong>在任何一个程序里面都一定会有大量的名称进行一些特定结构的声明，例如：在Java程序里面一直强调，每一个程序都是一个类，那么所有的类就一定要有类的名称，这就是属于一个标识符，所有的程序编译器都是依据这个名称来进行代码结构管理的，既然要进行管理，对于名称就有它的命名要求。</strong></p>
<pre><code>在java之中所有的标识符由字母、数字、下划线（_）以及“$”所组成的，其中不能使用数字开头，不能够使用java关键字（保留字）进行标识符定义。
顺便说一下：正常的标识符里面一般都要求有具体的严格意义，例如：你在程序里面定义了a、b、c一系列的标识符，那么这些意义不明确，所以代码
阅读起来是非常困难的。另外对于标识符定义中的“$”也不要去直接使用，因为其有特殊的含义，所以一般来讲标识符的组成就是字母、下划线、数字
所组成的，建议使用字母开头。</code></pre><blockquote>
<p><strong>yootk_name,YootkDemo,teacherLee,num_110</strong>(正确形式)</p>
</blockquote>
<blockquote>
<p><em>110_No.1</em>(使用数字开头、并且使用了“.”作为了标识符的组成)<br><em>abc#hello</em>(使用了非法的“#”符号作为了标识符)<br><em>class</em>(使用了程序中的关键字（保留字），那么这种标识符也是错误的。)</p>
</blockquote>
<p>　　<strong>任何的编程语言里面都会提供有大量的关键字，这些关键字往往都具有特殊的含义，java中的关键字会随着每次版本的更新而有所扩充。</strong></p>
<blockquote>
<p>很多的语言里面都有许多相同的关键字（java、C、++是一个系列的）：for,if,else,swich,while、……；<br>java有两个未使用到的关键字：goto（代码调试的万恶之手）、const(定义常量，被final所取代)；<br>有三个特殊含义的标记（严格来讲不属于关键字）：null、true、false；<br>JDK1.4之后更新了assert关键字，用于断言操作；<br>JDK1.5之后扩充了enum关键字，用于进行枚举定义；<br>JDK1.10之后扩充var关键字，用于进行匹配类型变量的定义；<br>JDK1.13之后扩充yield关键字，进行局部返回。</p>
</blockquote>
<p><em>除了以上的标识符定义要求之外，实际上java也考虑到中国的地位，也推出了一些比较神奇的做法，可以直接使用中文进行标识符的定义。</em></p>
<p><strong>范例：使用中文标识符</strong></p>
<pre><code>    public class 优拓公开课{ // 【单行注释】定义程序的执行主类
    public static void main(String args[]){// 【单行注释】程序的执行起点，主方法
        /*【多行注释】
            以下的程序代码是在屏幕上进行一些提示信息的输出，如果有需要则可以再里面进行多行的定义    
        */
        int 年龄 = 18;//中文定义
        System.out.println(&quot;Hello world!&quot;); 
        // 【代码失效】 System.out.println(&quot;江湖上称我为&quot;); 
    }
}</code></pre><p>​    这种定义的形式可以作为娱乐，但是正常的开发者一般都不会采用这样的形式来进行标识符的定义，还应该使用传统的字母、数字之类的进行定义，除了标识符的组成要求之外，在Java里面或者是在实际的工作之中还会有一些命名规范的出现，命名规范都要求遵循标识符的组成原则，但是对于大小写的定义是有描述的，例如：类名称每个单词的首字母大写（例如：YootkDemo）,这些具体的描述可以根据不同的公司来动态调整。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p><strong>任何的程序设计语言本身就属于一场数字的游戏，如果说我们的人生就是一部自我完善的坚史，那么编程语言既然是一种现实物理和数学的抽象，其背后就是数字的一场游戏（计算机的组成的核心本质只有数字：“0”、“1”），那么既然要进行数字的操作，则需要进行数据的存储，所以任何的编程语言里面都会设计有一系列的数据类型，利用不同的数据类型保存相应的类型</strong></p>
<p><em>例如：如果要是描述年龄，那么肯定要使用整数。如果要进行折扣处理的话，往往就希望这个小数点越小越好，所以就需要浮点型。所以任何一门完善的编程语言其数据类型的支持程序都是异常丰富的。</em><br>　　<strong>在java程序的内部对于数据类型实际上分为两大类型：</strong></p>
<blockquote>
<p>【分类】基本数据类型：所有的数据操作都是采用值传递，相当于把数据给了对方一个副本信息，副本信息的修改不影响原始的数据内容，这些基本数据类型也是构成程序开发的基本环节；</p>
</blockquote>
<pre><code>|-【子分类】整型：byte、short、int、long;        --&gt;默认值：0
|-【子分类】浮点型（有小数点=小数）：float、double;    --&gt;默认值:0.0
|-【子分类】字符型：char;                --&gt;默认值:&apos;\u0000&apos;(十六进制)
|-【子分类】布尔型：boolean.                --&gt;默认值:false(特殊意义的关键字)</code></pre><p>​    </p>
<blockquote>
<p>【分类】引用数据类型：是进行内存的数据操作，给的内存使用权。是所有初学者最难理解的部分；</p>
</blockquote>
<pre><code>|-有三种引用数据类型：数组、类、接口。            --&gt;默认值:null(特殊意义的关键字)

提示：整个的Java编程语言之中由于对C、C++进行了结构上的优化(Java是基于C++开发出来的),在整个的C、C++里面最让人头疼的部分就是指针，而java为了解决这个问题，取消了指针的定义，而使用了更加简单的引用数据类型来进行代替，在后面进行面向对象讲解开始的时候将对引用数据类型做出全面的分析</code></pre><p>　　<strong>在java开发过程之中，对于基本数据类型（最为核心的数据类型）默认一共提供有八种类型，其中有7种类型是由明确的数据存储范围（计算机里面所有的数据内容都是通过二进制的形式保存的，所有的数据都有一个保存的上限&amp;下限）</strong></p>
<pre><code>-byte: 描述的是字节，在进行网络数据传输一定是字节数据处理，也会用在编码转换上；（1字节）
-int：描述的是整型，例如：定义年龄；（4字节）
-long：描述的是长整型（范围比int广），用在进行文件大小描述、日期时间的描述上；（8个字节）
-double：描述小数，例如：要进行工资的定义，则肯定是小数；（8个字节）
-char：主要是进行中文处理；（2个字节）
-*boolean*：进行逻辑表述。</code></pre><h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><p>  <strong>变量与常量是在整个程序计算过程之中主要使用的两个数据的存储形式，其中所有给定的不可能修改的内容我们将其称为常量，而所有可以修改的内容就将其称为变量。</strong></p>
<p><em>范例：观察变量</em></p>
<pre><code>public class DongJun{ 
public static void main(String DongJun[]){
    //10是一个数字，既然已经定义好了10，那么就意味着这个内容无法修改了
    System.out.println(10); //常量
}
}</code></pre><blockquote>
<p>程序执行结果:10</p>
</blockquote>
<p><strong>在上学的时候学校经常会用一种方式去惩戒哪些所谓的“调皮的学生”，就是将你的行为和处分决定记录在你的档案里面，这些内容将持续陪伴你，并且不会变更，那么就可以将这些记录定义为你个人的常量</strong><br><em>变量顾名思义就是内容可以改变的标记，所有的变量都一定要有其对应的数据类型，例如:int,double都属于数据类型，每一种变量可以根据其定义的数据类型进行内容的修改。</em></p>
<blockquote>
<p> <strong>如果要想使用变量则必须进行定义，而变量的定义语法形式为：“数据类型 变量名称 = 默认值”，而这个变量名称实际上就是之前讲解的标识符的组成，相当于你自己定义的有意义的名称。</strong></p>
</blockquote>
<p><em>范例：定义变量</em></p>
<pre><code>public class DongJun{ 
public static void main(String DongJun[]){
    //所有程序语言最后一定要使用;作为结尾
    int age = 10;//定义一个整型变量，并且设置了默认值
    System.out.println(age); //输出变量内容
    age = 19; //赋值
    System.out.println(age); //输出变量内容
}
}    </code></pre><blockquote>
<p>程序执行结果： 18<br>       19</p>
</blockquote>
<p><strong>按照正常的设计来讲每一种数据类型即便不设置默认值，那么也应该使用其对应数据类型的默认值进行定义，但是如果你的代码写成如下的形式，则执行的时候一定是错误的</strong></p>
<pre><code>public class DongJun{ 
    public static void main(String DongJun[]){
        int age ;//如果现在没有定义具体的内容，则应该使用默认值“0”来表示
        System.out.println(age);
    }
}</code></pre><blockquote>
<p>D:\yootk&gt;javac DongJun.java<br>DongJun.java:4: 错误: 可能尚未初始化变量age<br>                  System.out.println(age);</p>
</blockquote>
<p><strong>本次主要是观察变量声明和赋值在不同的JDk版本里面所带来的流程上的区别。</strong><br><em>范例：在JDK1.4及以前的版本</em></p>
<blockquote>
<p>要求在主方法中定义变量的同事一定要为其设置默认值，如果不设置就出错；</p>
</blockquote>
<p><em>范例：在JDK1.5及以及以后</em></p>
<blockquote>
<p>在主方法中定义变量的时候可以不设置默认值，但是在其使用之前一定要进行默认值设置，否则会出现编译错误</p>
</blockquote>
<p><strong>如果把常量比喻为不同的咖啡：美式、拿铁、卡布奇诺，这些调制好了的东西一般是不会发生改变的，而如果是变量那么就好比是你的咖啡杯，咖啡杯可以装不同咖啡，但是当你需要更换咖啡的时候，那么就意味着你原始的咖啡就没了，而盛的咖啡就是新的。</strong></p>
<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><p><strong>在现实的生活里面数学上一般都会存在有整数的概念，整数实际上描述就是没有小数点的内容，是一个完整的十进制的数值。</strong><br><em>例如：如果要想表示一个人的年龄肯定要使用整数，如果要想去描述住房楼层肯定也使用整数，在Java程序里面，对于整数的数据类型一共有四种支持：Byte、short、int、long。</em><br>　　在给定的这四种整型数据类型里面，最为常用的数据类型就是Int型，在java程序之中任何的一个整型数字的常量默认对应的类型全部都是整型。<br><strong>定义int变量</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        //数据类型 变量名称 = 常量、整数常量的默认类型为 int
        int number = 10; //定义一个整型变量
        // int变量-=  int变量数值 + 20 常量（int类型）
        number = number + 20; // 进行变量的加法计算
        System.out.println(number);
    }
}    </code></pre><blockquote>
<p>程序执行结果：30</p>
</blockquote>
<p><em>虽然int 可以解决大部分的整型的数据操作问题，但是从另外的角度来讲，对于当前程序开发来说，int本身是由其长度范围(-2147483648-2147483647),那么如果说超过了这个计算范围，则就有可能出错。</em></p>
<pre><code>public class DongJun{ 
static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
public static void main(String DongJun[]){
    //数据类型 变量名称 = 常量、整数常量的默认类型为 int
    int max = 2147483647; //定义一个整型变量
    // int变量-=  int变量数值 + 20 常量（int类型）
    max = max + 1; // 进行变量的加法计算
    System.out.println(max);
}
}</code></pre><blockquote>
<p>程序执行结果-2147483648</p>
</blockquote>
<p>这里面就存在了计算机之中的基本概念：二进制的数据计算问题了。在程序之中所有的数据都是被二进制的操作进行管理的，但是由于Java编程语言属于高级编程语言，所以对于一些底层的细节就由编程语言自己来处理。</p>
<pre><code>专业描述：Java之中int数据类型一共有32位，第一位属于符号位，其余的位数属于数据位。每一次进行所谓的加或减的时候实际上都是在底层进行了二进制数据计算，当已经最大值的似乎还“011111”，如果再进行加1的处理，符号位就会发生改变，所以就变为了最小值。</code></pre><p>　　<em>对于以上的问题在程序开发之中可以理解为数据的溢出，数据溢出采用的是一种循环的模式进行处理的。</em></p>
<p><strong>如果要想解决这种数据溢出的问题，那么最佳的做法就是扩大使用的数据范围，比int范围更大的数据范围就是long，所有的编程语言里面对于数据范围的扩大都使用自动的扩大的形式，例如：如果现在是一个int型变量和一个long型变量进行加法操作，那么必定要先进行数据类型的统一，而这种统一的操作过程就是将int类型自动转为long的类型。从而形成最终的两个long型变量的计算操作。</strong><br>范例：通过long数据类型解决int的溢出问题</p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        //数据类型 变量名称 = 常量、整数常量的默认类型为 int
        int max = 2147483647; //定义一个整型变量
        // int变量-=  int变量数值 + 20 常量（int类型）
        System.out.println(max+1L);
    }
}</code></pre><blockquote>
<p>程序执行结果2147483648</p>
</blockquote>
<blockquote>
<p>由于默认的整数对应的类型为int,<em>所以如果要想将其变为long的常量则可以使用“整数L”、“整数l”（“小写L”比较坑）因为其长的和1很相似（如果你没有受过一定的训练是看不出的）</em><br><strong>结论：如果要想解决数据溢出问题，肯定要使用更大的数据类型来进行处理。</strong></p>
</blockquote>
<p>　　<em>这个时候就会出现一个新的概念：数据类型的转换，不同的数据类型之间是可以进行转换的，但是在进行转换的处理过程之中一般都会使用如下的两个转换原则。</em></p>
<blockquote>
<p>自动类型转换：保存数据范围小的数据类型如果遇见了保存范围数据大的数据类型，则范围小的数据类型自动转换为范围大的数据类型后再进行计算，之前的程序就属于这种自动转换。</p>
</blockquote>
<p><em>范例：数据类型的自动转换</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        //数据类型 变量名称 = 常量、整数常量的默认类型为 int
        int num_a = 10 ;
        long num_b = 20;
        //num_a这个int变量由于其数据类型的位数不足，所以将自己转换为long类型后在于num_b进行加法计算
        lonmg result = num_a + num_b;
        System.out.println(result);
    }
}</code></pre><p>​    </p>
<blockquote>
<p>强制类型转换:将保存数据范围大的数据类型强制的变为保存数据范围小的数据类型，这种转换由于需要缩小数据类型的保存位数，所以就有可能产生数据溢出问（数据出错）</p>
</blockquote>
<p><em>范例：数据类型的强制转换</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        //数据类型 变量名称 = 常量、整数常量的默认类型为 int
        //此时必须强制性的将整型常量转为long类型才可以正常保存在long变量之中
        long num = 2147483677L; //该类型已经超过了int的最大内容
        System.out.println(num);
        System.out.println((int)num);
    }
}</code></pre><blockquote>
<p>2147483677<br>-2147483619</p>
</blockquote>
<p><em>*所以这种数据范围的强制转型所带来的最为严重的问题就是有可能会有数据的溢出情况出现，所以如果你非要进行强制性类型转型，那么一定要注意其最终的目标数据类型是否可以包含下当前的数据内容。</em><br>    　　<em>通过以上的分析实际上就可以得到一个最为重要的结论：在进行不同数据类型操作的过程之中，一定会首发发送自动的扩大类型的转型操作，而后再进行计算，但是一般不建议使用强制的类型转换，因为有可能会有数据溢出的问题。</em></p>
<p><strong>既然有了整型的概念，就必须重点分析一下byte数据类型问题</strong></p>
<pre><code>回顾：针对于不同数据类型的使用
    byte：主要用于网络传输、二进制数据处理、编码转换（在讲解IO和网络编程会使用到）
    int：描述大部分的整型数值，以后见到整型的需求首先考虑就是int型变量或常量；
    long：主要描述文件大小或者是日期时间的数字（以后讲解到类库的时候会进行说明）</code></pre><p><em>byte描述的是一个字节，java程序开发之中的每一个字节所能描述的数据范围:”-128-127”，就需要注意其不能够存储更大的数据信息。</em></p>
<p><strong>范例：定义byte变量</strong></p>
<pre><code>public class DongJun{ 
static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
public static void main(String DongJun[]){
    byte data = 10 ; //定义一个byte变量
    System.out.println(data);
}
}</code></pre><blockquote>
<p>10</p>
</blockquote>
<p><strong>以上的程序实现了最为基础的byte变量的定义以及内容的输出，但是在整个的程序执行过程之中会有一个小小的问题出现了：按照之前的概念来讲，此时的数字10应该是一个int型的常量，那么按照以上操作来讲应该是int型的常量赋值给了byte型的变量，出现了一个与之前概念不匹配的应用环境，之所以没有这种强制的转换需求，主要的原因在于：Java针对于符合byte范围内，那么就必须进行强制转换处理。</strong></p>
<p><em>范例：超过byte范围强制处理</em><br>    public class DongJun{<br>        static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>        public static void main(String DongJun[]){<br>            byte data = (byte)250 ; //定义一个byte变量<br>            System.out.println(data);<br>        }<br>    }</p>
<blockquote>
<p>-6</p>
</blockquote>
<p><em>此时由于设置的整型内容超过了byte范围，所以一旦强制性转换之后就产生了数据的溢出问题；</em></p>
<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><blockquote>
<p><strong>浮点型最大的特点就是在数字里面包含有小数点，在Java程序里面针对于浮点型数据类型提供了两个关键字：</strong></p>
</blockquote>
<pre><code>- 单精度浮点数据类型：float,包含32位的数据长度
- 双精度浮点数据类型：double,包含64位的数据长度
在Java里面，任何的一个小数其默认的数据类型均为double(double可以保存全宇宙里面最大的一个数值)，double是整个是所有数据类型之中可以保存数据内容最大的一种类型。</code></pre><p><em>范例：定义double变量</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        //double 变量 = 常量 (double变量)
        double num_a  = 99.89 ; //定义double变量
        int num_b = 199; 
        //double变量（num_a） + double变量(num_b，int自动转为double) = double结果
        double result = num_a + num_b ; 
        System.out.println(result);
    }
}

&gt;298.89</code></pre><p>　　<strong>java之所以没有使用float作为小数的默认类型，主要是考虑到float计算本身存在的二进制位的操作问题（会产生精度问题），这个问题是整个计算机编程语言行业之中最大的问题（娘胎带的问题了）,所以在java里面如果要想定义float变量，就必须将小数的常量进行强制的类型转换才可以正常进行。</strong></p>
<p><strong>范例：定义float型变量</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        float num_a  = 10.0F ; //将double常量强制转换为float变量
        float num_b  = (float) 0.4; //将double常量强制转换为float变量
        System.out.println(num_a/num_b);</code></pre><p>​<br>​                </p>
<pre><code>    }
}

&gt; 25.0</code></pre><p><em>范例：观察float可能存在的问题</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        float num_a  = 9.9F ; //将double常量强制转换为float变量
        float num_b  = (float) 0.3; //将double常量强制转换为float变量
        System.out.println(num_a/num_b);</code></pre><p>​<br>​            </p>
<pre><code>    }
}</code></pre><blockquote>
<p>32.999996(会出现许多小数)<br>　　<strong>float数据类型本身是有问题的，而正因为这些问题的存在，所以不建议使用float这种数据类型进行浮点数定义，最好使用double。</strong></p>
</blockquote>
<p><em>范例：通过double可以解决float的问题</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        double num_a  = 9.9 ; //将double常量强制转换为float变量
        double num_b  =  0.3; //将double常量强制转换为float变量
        System.out.println(num_a/num_b);</code></pre><p>​<br>​                </p>
<pre><code>    }
}</code></pre><blockquote>
<p>33.0</p>
</blockquote>
<p>　　<em>在以后的项目开发过程之中肯定要首选double作为小数的数据类型。</em></p>
<p><strong>在项目的开发之中整型和浮点型之间最大的区别就是小数点，也就是所有的整型数据内容是不会保留小数位的，那么如果说现在计算的数据本身会产生小数位，则如果没有使用浮点型而使用整型，对应的小数位会全部丢弃。(如果要想准确，那么就必须采用小数来进行计算，需要将其中的一个计算的内容变成double)</strong></p>
<p><em>范例：解决小数点的保留问题</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int num_a = 9 ;
        int num_b = 2 ; 
        System.out.println(num_a/(double)num_b);

    }
}</code></pre><blockquote>
<p>4.5</p>
</blockquote>
<p><strong>如果在计算之中某一个类型变为了double，则其他的类型都要变为double（double范围是最广的），这个时候当前的计算结果一定是double类型。</strong></p>
<pre><code>通过以上的分析，应该就已经非常清楚了这些数值型的数据类型的自动转换操作过程：byte&gt;short&gt;int&gt;long&gt;float&gt;double(保存范围小的自动进行转换),而在进行强制类型转换的时候，如果浮点型强制变为了整型，那么就会丢掉小数点。</code></pre><blockquote>
<p>在未来选择数值型数字类型的时候，整型就使用int,浮点型（小数）就使用double</p>
</blockquote>
<h1 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h1><p>　　<em>在java程序里面，依然提供有传统编程语言使用的字符的概念，字符是使用“’”声明的一个内容，字符提供有char关键字来进行类型的定义。</em></p>
<p><em>范例：字符的定义</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        char c=  &apos;y&apos;;//字符需要使用单引号进行声明
        System.out.println(c);

    }
}</code></pre><blockquote>
<p>y</p>
</blockquote>
<p><strong>在使用字符进行初始化内容赋值的时候后，一定只能够设置一位内容，如果设置了多位，语法一定会出错。</strong>　</p>
<p>　　<strong>在程序之中字符（char）可以和整型（int）直接进行转化处理，而字符转换为整型之后得到的数值就属于字符的编码。</strong></p>
<blockquote>
<p>　　那么既然所有的字符在JVM里面都有相应的编码存在，这样一来就必须非常清楚几个常见的字符范围的定义：</p>
</blockquote>
<pre><code>小写字符范围（&apos;a&apos;~&apos;z&apos;）:97~122;
大写字符范围（&apos;A&apos;~&apos;Z&apos;）:65~90;
数字字符范围（&apos;0&apos;~&apos;9&apos;）:48~57</code></pre><blockquote>
<p>于是这个时候有人发现一个问题：大写字符和小写字母之间的编码的数值内容差32个，所以理论上修改数值就可以进行大小写的控制，下面市县一个小写字母转大写字母的操作。</p>
</blockquote>
<p><em>范例：小写字母转为大写字母</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        char c=  &apos;a&apos;-32;//字符需要使用单引号进行声明
        System.out.println(c);

    }
}</code></pre><blockquote>
<p>A</p>
</blockquote>
<p><strong>通过以上的分析实际上是许多的读者就应该发现一个比较熟悉的昌吉了，这个场景的内容就是常规的编程语言里面所出现ASCII码的内容（在整个计算机内部核心的组成就是”0”,”1”），但是需要描述的内容太多了，所以就需要对这些数值进行合理的安排，就可以基于不同的内容实现相应字符的显示</strong></p>
<pre><code>需要提醒读者的是，在使用java开发的时候后，所采用的并不是这种ASCII码，JAVA在其设计的时候已经充分的考虑了当前的开发市场（C、C++为主时代）所有的开发者都已经习惯于这样的编码顺序，那么在进行java编码的设计的时候就将传统的ASCII码包含在当前语言设计的编码当中，开发了属于JAVA自己的十六进制编码，该编码的名称为“UNICODE”。UNICODE是一个非常强大的编码，可以描述出世界上任意的文字，包括中文、日文等。</code></pre><p><em>范例：通过char保存中文</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        char c=  &apos;俊&apos;;//传统的ASCII码是不包含中文定义的
        int num = c;
        System.out.println(num);

    }
}</code></pre><blockquote>
<p>20426（这个数值已经远远超过了byte可能描述的数据范围）</p>
</blockquote>
<p>　　<em>UNICODE描述了一个更广阔的编码范围，其中也很好的支持有传统的AsCII编码，让所有的开发者在使用上不会产生任何的不适应感。由于字符可以保存中文，所以在日后进行网络数据传输的时候，如果要进行中文数据的处理，建议使用的就是char来进行操作。</em></p>
<h1 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h1><p>　　<em>布尔型是一种描述处理结果的逻辑内容，对于计算机的世界来讲除了真就是假，没有中间的过渡环节，布尔在java编程语言里面使用boolean关键字来进行定义，而布尔的取值只有两个内容：True、False（这两个在java中都属于有特殊含义的关键字）</em></p>
<p><strong>如果要想使用布尔类型进行程序的开发，往往都需要结合一些分支语句的结果进行使用</strong></p>
<p><em>范例：使用布尔型</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        boolean flag = true;
        if(flag){
            System.out.println(&quot;1&quot;);
        }
    }
}</code></pre><p>**　　如果此时设置flag的内容为false，那么对于当前的if判断就不会成立。既然已经谈到布尔数据类型就必须对一个语言的区别进行一些描述。**</p>
<p>　　<em>如果你使用的是C、C++编程开发，在这样的编程语言里面基本上强调都是通过数字0来描述FALSE，而通过一个非0的数字来描述TRUE，通过这样的数值来描述布尔值，但是在JAVA之中并不存在于这样的概念。</em></p>
<h1 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h1><p>　　<strong>在任何一门语言里面实际上字符串都属于一种比较特殊的类型，而JAVA之中字符串也属于非常特殊的一种数据形式，它不是基本数据类型，而它属于一种引用数据类型，因为字符串的类型要使用“String”声明，而在JAVA编写程序代码的过程之中已经明确强调了：首字母大写的一定是类，所以String是一个系统类（这个系统类的设计是非常繁琐的，后面会有专门的内容进行全面分析），本次先来观察一下String的基本使用</strong></p>
<p>　　<em>在程序里面如果要想描述单个字符肯定要使用char类型（通过“’”声明），但是如果要想描述一组的字符，就可以通过字符串的形式来处理。</em></p>
<p><em>范例：定义字符串</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        String message = &quot;董俊&quot;;
        System.out.println(message);

    }
}</code></pre><blockquote>
<p>董俊</p>
</blockquote>
<p>**　　需要注意的是，每一个字符串实际上都可以进行内容的连接，而内容的连接，可以通过“+”来实现（不是数字的加法而表述的是一个连接操作）**</p>
<p><strong>范例：字符串连接操作</strong><br>        public class DongJun{<br>            static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>            public static void main(String DongJun[]){<br>                String message = “姓名：”;<br>                message =  “我的” + message ;<br>                System.out.println(message+”董俊”);</p>
<pre><code>    }
}</code></pre><p>　　<em>既然在字符串之中“+”属于连接的操作形式，所以这个时候就会存在有另外一个问题：如果现在直接与其他基本数据类型进行连接又会如何呢？</em></p>
<p><strong>范例：观察基本数据类型与字符串的连接</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        String prompt = &quot;数据输出&quot;;
        System.out.println(prompt + 1);
        System.out.println(prompt + 1.1);
        System.out.println(prompt + &apos;Y&apos;);
        System.out.println(prompt + true);


    }
}</code></pre><blockquote>
</blockquote>
<p>数据输出1<br>数据输出1.1<br>数据输出Y（字符并没有变为数字，而是直接使用了原始的字符内容）<br>数据输出true</p>
<p><strong>以上仅仅是连接了一些基本数据型常量，那么如果说现在连接的是一些基本的计算表达式，那么请继续观察程序问题。</strong></p>
<p><em>范例：观察计算表达式问题</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        double num_a = 9.5 ;
        int num_b  = 3 ;
        System.out.println(&quot;数学计算:&quot;+num_a + num_b);
    }
}</code></pre><blockquote>
<p>数学计算：9.53（字符串连接）</p>
</blockquote>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        double num_a = 9.5 ;
        int num_b  = 3 ;
        System.out.println(&quot;数学计算:&quot;+(num_a + num_b));
    }
}</code></pre><blockquote>
<p>数学计算:12.5（先数学计算再连接）</p>
</blockquote>
<p>**　　之所以此时要强调这种问题的关键在于，在进行字符串处理的时候“+”和数学计算的“+”会有那么一些麻烦的表述，当java任何的数据类型与字符串进行连接的似乎还，所有的数据类型会首先变为字符串，按照此时的代码，首先执行的是“字符串+double变量”，自动转为String的字符串，而后这个字符串再通过“+”连接一个整型，这个时候的整型也会自动转为字符串，所以最终的计算就称为了一个字符串的连接操作，而加上了括号之后表示要先计算括号内部的数据加法（double类型），最后再与字符串进行连接操作（double自动转为了String）但是这些操作仅仅是发生在包含有“+”的概念上，如果使用的是其他的运算，例如使用的是“-”，那么该程序在编译的时候就会出错**</p>
<pre><code>另外需要提醒大家的是，在进行字符串定义的时候本身如果包含有一些特殊的内容肯定是无法直接定义的，所以在这样的情况下要想描述一些特殊标记的符号就要使用转义字符，常见的转义字符为：双引号（&quot;、“\&quot;”）、单引号（&apos;、“\&apos;”）、换行符(“\n”)、制表符（“\t”）。</code></pre><p><em>范例：观察转义字符</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        String message = &quot;董俊\&quot;\n\\\t我的填&quot;;
        System.out.println(message);
    }
}</code></pre><p><strong>这些转义字符也就在基础学习的过程之中有些作用，主要可以让内容的输出更加好看一些，但是如果在实际上的开发里面用处不是特别大</strong></p>
<h1 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h1><pre><code>Java 本身属于一门静态变成语言，在进行各个变量定义的时候就必须明确的声明变量的类型以及变量的具体内容（JDK1.5之后的版本要求是在使用之前复制），但是随着当今时代编程语言的技术发展，对于编程语言的要求也开始变得更多，所以这个时候很多的语言就退出了一个所谓的推断式变量定义，后来java在JDK1.10版本之中正式引入了此机制，所以提供了一个新的var关键字，这个关键字主要用于进行变量的定义，并且会根据所赋予的内容进行自动类型的配置。</code></pre><p><strong>范例：观察var关键字的使用</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        var num_a = 10.2 ;//将自动推断num_a类型为double
        var num_b = 3 ;//将自动推断num_b类型为int
        System.out.println(num_a - num_b);

    }
}</code></pre><blockquote>
<p>7.199999999999999(这种精度问题可以忽略)</p>
</blockquote>
<pre><code>public class DongJun{ 
static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
public static void main(String DongJun[]){
    var num_a = 10.2 ;//将自动推断num_a类型为double
    var num_b = 3 ;//将自动推断num_b类型为int
    System.out.println(((Object)num_b).getClass());//class java.lang.Integer
    System.out.println(((Object)num_a).getClass());//class java.lang.Double

}
}</code></pre><p>**　　在使用var关键字的时候除了可以为其赋值为基本数据类型之外，也可以设置字符串变量。**</p>
<p>范例：定义字符串变量</p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        var message  = &quot;董俊&quot;;
        System.out.println(message);

    }
}</code></pre><blockquote>
<p>董俊</p>
</blockquote>
<p>**　　于是这个时候就有人提出疑问了，按照现在的做法，感觉所有的变量都使用var定义实际上减少了我们对于关键字的记忆需求，为什么你又在这边强调不要去使用它呢？**</p>
<pre><code>个人总结两个缺点：
    缺点一：像传统C、C++、Java这样编程语言对于数据类型都是有非常严格的要求，所以其对应的数据类型如果写的非常明确，那么就适合于程序的编写与调试，而如果使用var直接定义，那么类型不明确，于是世界上有一种变量的声明格式采用的是加入数据类型的模式完成例如：“var double_num_a = 10.2;”

    缺点二：其他语言的var是真正的动态类型（随时可以改变变量所保存的数类型的），而Java之中只是提供了一个var样子而已（一旦定义了变量，并且已经推断出了类型之后，那么该变量所保存的类型不允许改变）。</code></pre><p><em>范例：错误的var操作</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        var num = 10.2;
        num = &quot;www.yootk.com&quot;;</code></pre><p>​<br>​        }<br>​    }</p>
<blockquote>
</blockquote>
<p>DongJun.java:5: 错误: 不兼容的类型: String无法转换为double<br>                num = “<a href="http://www.yootk.com&quot;" target="_blank" rel="noopener">www.yootk.com&quot;</a>;<br>                      ^<br>1 个错误<br>错误: 编译失败</p>
<p><strong>综合以上的结论来讲，var关键字这种所谓的数据类型推断于实际的开发意义确实不是很大，这种操作尽量慎用</strong></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><pre><code>编程语言的本质是在于数学的计算（包括整个计算机的组成都是依据数学公式“冯诺依曼”），如果我们现在的程序开发使用的还是低级语言（汇编语言），那么所有的开发者就必须进行大量的细节处理，计算机的基本组成为二进制的数据，所以对于正数、负数、小数都需要进行各种二进制的计算转换，才可以通过计算机进行处理，但是如果所有的开发代码都还保持着这些低级语言的开发环境，那么对于技术的发展是非常不利的。</code></pre><blockquote>
<p><strong>放低思维：在国内的互联网的历史上，百度肯定是作为一家搜索引擎的公司出现的，他自己有自己的开发技术，但是在早期的互联网时代之中，实际上为了便于上网出现了所谓的导航网站（早期的Yahoo）。</strong><br><strong>在国内的“hao123.com”，本身没有任何的技术难度，所以在这样的情况下，许多的初级网民就觉得非常好用，于是最终2000W卖给了百度.</strong></p>
</blockquote>
<p>*　　如果所有的程序中的数学计算都要求每一位开发者进行所有底层的处理转换，那么计算机的发展肯定无法前进，那么作为高级编程语言（C、C++、JAVA、Python等），就必须读这些数学计算进行一系列的简化处理，所以才提出了所谓的运算符的概念，通过各种运算符以及编译操作过程就可以简化所有的计算处理。*</p>
<pre><code>通过之前的学习实际上以及接触了两类运算符：
    |-赋值运算符：变量 = 内容（数据）、 变量 = 其他变量；
    |-数学运算符：+、-、*、/;
而除了以上可以见到的运算符之外，在Java程序之中依然还包括有许多的运算符，那么这些运算符基本的使用过程实际上和正常生活的数学逻辑是非常贴近的。</code></pre><p>**　　重要的运算符：四则运算、逻辑运算（大小关系）、三目运算、自增或自减运算，除了这些基本的运算符之外，实际上所有的运算符都有其运算优先级（先乘除后加减）**</p>
<p><strong>高手的编程</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int a = 10;
        int b = 20;
        int result = a++ - b++ * a - b-- /  ++b * ++a;
        System.out.println(result);

    }
}</code></pre><blockquote>
<p>-222(不要问为什么)</p>
</blockquote>
<pre><code>在你以后的开发生涯之中，如果你真的写出了这样代码，接手你代码的后续的开发者一定会跑路。

随着开发产业的不断发展，那么所谓的优秀的代码大部分都会有一种固定的特征：“全部编写简单按程序”，所有的代码可以像“1+1= 2”那样简单。</code></pre><h1 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h1><pre><code>数学运算符是整个运算符之中最接近于原生生活的一种运算符，利用数学运算符可以方便的实现四则运算（加、减、乘、除、模），除了标配的运算符之外还提供有简化运算符。

模（MOD）：在实际的项目开发过程里面，求模的意义可以实现数的批量控制，例如：每20个人站为一组</code></pre><p>范例：通过求模的方式进行批量处理</p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int currentNumber  = 20 ; //定义变量
        int result = currentNumber % 20; // 如果先currentNuumber不是20，则模的结果一定不是0
        System.out.println(&quot;运算结果：&quot;+result);

    }
}</code></pre><blockquote>
<p>运算结果： 0</p>
</blockquote>
<pre><code>对于求模的操作可能比较接近于当前基础环境的就只有一个常用的功能了：判断奇偶数（奇数模2为1，偶数模2为0）</code></pre><p><strong>实现奇偶数判断</strong></p>
<p>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写<br>        //Java中类的定义规则：每一个单词的首字母必须大写<br>        int number =  3; // 定义变量<br>        int result   = number % 2 ;<br>        System.out.println(“运算结果：”+result);<br>    }<br>}</p>
<blockquote>
<p>运算结果：1（现在判断的数字是一个奇数）</p>
</blockquote>
<p><strong>范例：简化运算符</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int numberA =  33; // 定义变量
        int numberB =  33; // 定义变量
        int numberC =  33; // 定义变量
        int numberD =  33; // 定义变量
        int numberE =  33; // 定义变量
        numberA += 5;
        numberB -= 5;
        numberC *= 5;
        numberD /= 5;
        numberE %= 5;
        System.out.println(&quot;运算结果A：&quot;+numberA);
        System.out.println(&quot;运算结果B：&quot;+numberB);
        System.out.println(&quot;运算结果C：&quot;+numberC);
        System.out.println(&quot;运算结果D：&quot;+numberD);
        System.out.println(&quot;运算结果E：&quot;+numberE);
    }
}</code></pre><blockquote>
</blockquote>
<p>运算结果A：38<br>运算结果B：28<br>运算结果C：165<br>运算结果D：6<br>运算结果E：3</p>
<h1 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h1><pre><code>在Java运算符里面针对于数学运算提供有“++”（自增运算，每一次调用内容都会“+1”处理）、“--”（自减运算，每一次调用内容都会“-1”处理），那么首先先来观察一下这两个运算符的基本使用。</code></pre><p><strong>范例：使用自增</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int num = 10 ; 
        System.out.println(&quot;原始num变量内容:&quot; + num);
        num++;//num+ = 1，但是性能要更高
        System.out.println(&quot;自增后num变量内容:&quot; + num);
    }
}</code></pre><blockquote>
</blockquote>
<p>原始num变量内容:10<br>自增后num变量内容:11</p>
<p>**　　当执行了自增操作之后，原始内容会增加1**<br>以上见到的自增是我们在实际开发中最为推荐的操作方法，但是对于当前自增或者是自减运算又会根据位置的不同而有所不同，主要是发生在执行顺序上。</p>
<pre><code>自增
&quot;变量 ++&quot;：先计算后累加
&quot;== 变量&quot;：先自增再计算
自减
&quot;变量 --&quot;：先计算后自减
&quot;-- 变量&quot;：先自减再计算</code></pre><p>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写<br>        //Java中类的定义规则：每一个单词的首字母必须大写<br>        int numA = 10;<br>        int numB = 5;<br>        int result = numA + numB++;<br>        System.out.println(“计算结果:” + result);<br>        System.out.println(“numA=” + numA + “、numB=”+ numB);<br>    }<br>}</p>
<blockquote>
<p>计算结果:15<br>numA=10、numB=6</p>
</blockquote>
<p><strong>以上就实现了自增和自减</strong></p>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><pre><code>在程序设计之中对于数据的关系基本上就是：&gt;, &lt;, &gt;=, &lt;=, （不等于）!=, （等于）==
这些关系运算符可以直接应用在数值的描述上（字符本身也是可以与整数进行自动转换，所以字符上也可以使用。）</code></pre><p><strong>范例：比较两个数字的大小关系</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int zsAge =  10 ;
        int lsAge =  20 ;
        boolean result = zsAge &gt; lsAge;
        System.out.println(result);
    }
}</code></pre><blockquote>
<p>False</p>
</blockquote>
<p><em>所有的关系运算符计算完成之后的数据类型是布尔类型（它的取值范围（True、False））</em></p>
<p><strong>范例：实现浮点型数据比较</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int zsAge =  10 ;
        int lsAge =  20 ;
        boolean result = zsAge &gt; lsAge;
        System.out.println(result);
    }
}</code></pre><blockquote>
<p>true</p>
</blockquote>
<p>**　　直接利用数值的比较是在进行关系运算符处理过程之中最为常见的数据类型，但是千万不要忘记了，由于java程序本身使用了十六进制的UNICODE编码，所以所有的字符内容都可以转为十进制数字。**</p>
<p><strong>范例：字符和整数进行比较</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        char name = &apos;董&apos;;//中文都是有编码
        System.out.println(name == 33891);

    }
}</code></pre><blockquote>
<p>true</p>
</blockquote>
<pre><code>不同的数据类型彼此发生数据大小比较之后一定要发生转型问题，如果转型失败（这种明面上的数据类型，如果真有转型失败的问题，那么编译器会直接告诉使用者可能出现的语法错误）那么一定无法进行比较，所以本次字符一定是首先自动的转为整型，而后利用整型数值进行相等的判断。</code></pre><p><strong>范例：布尔型的相等和不等判断</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        boolean flagA = true;
        boolean flagB = false;
        System.out.println(flagA == flagB);
        System.out.println(flagA != flagB);

    }
}</code></pre><blockquote>
</blockquote>
<p>false<br>true</p>
<pre><code>由于布尔数据类型的取值范围的定义，所以在使用关系运算符进行布尔数据类型判断的时候，只能够使用相等和不等两个运算符。，而其他的关系运算符将无法使用。</code></pre><h1 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h1><pre><code>如果同学们仅仅是在基础课程的学习过程之中实际上是很难感受到三木运算符的优势（在日后进行代码开发的过程里面，三目运算符相当的好用，同时可以帮助所有的人解决许多的代码冗余的问题）。
|- 三目运算符的本质相当于是一个带有判断的赋值运算符， 传统的赋值运算符能够设置的内容基本上就是变量或者常量，它采用都是比较直白的模式</code></pre><p>**　　如果某些值需要有条件的进行赋予则就必须进行一些关系运算符的判断处理了，当符合于某些判断条件的时候赋值，如果不符合赋予另外一个数值，而这个过程就属于三目运算符的操作，该操作的基本语法形式如下。**</p>
<pre><code>语法形式：[数据类型] 变量 = 判断条件 ? 条件满足时复制内容：条件不满足时赋值内容;</code></pre><p><strong>范例：观察三目运算符的使用</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int ageA = 10;
        int ageB = 15;
        int maxAge = ageA &gt; ageB ? ageA : ageB;
        System.out.println(maxAge);
    }
}</code></pre><blockquote>
<p>15</p>
</blockquote>
<blockquote>
<p><strong>对于此时的三目运算符相当于使用了一个if分支语句进行判断处理操作。</strong></p>
</blockquote>
<p><em>范例：三目等价于if、else判断</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int ageA = 10;
        int ageB = 15;
        int maxAge = 0;
        if (ageA &gt; ageB)
        {
            maxAge  = ageA;
        }
        else {
            maxAge  = ageB;
        }
        System.out.println(maxAge);
    }
}</code></pre><blockquote>
<p>最终输出结果同上</p>
</blockquote>
<pre><code>实际上在所有的运算符使用的过程之中都是可能存在有嵌套关系的，下面实现一个三目运算的嵌套处理。</code></pre><p><em>范例：实现三目运算的嵌套</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int ageA = 10;
        int ageB = 15;
        int ageC = 18;
        int maxAge = ageA &gt; ageB ? ageA : ageB &gt; ageC ? ageB : ageC ;
        System.out.println(maxAge);

    }
}</code></pre><blockquote>
<p>18</p>
</blockquote>
<p>**　　对于此时的程序的操作结构实际上是不便于阅读的，提倡编写简单代码。**</p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><pre><code>逻辑运算主要描述的是与或非这样的基本关系，使用逻辑运算符最终的特点在于可以同时连接多个判断条件。
例如：在之前使用的关系运算符，每一次只能够进行一个条件的判断，这样的操作一定不适合于更加复杂的程序逻辑。

逻辑运算符
----------------------------------------------------------
|-与（&amp;普通与和&amp;&amp;短路与）：若干个判断条件同时为true，最终程序结果才是true;
|-或：(|普通或||短路或)若干个判断条件有一个为true，最终程序运算的结果就是true;
|-非：（！）true变为false、false变true。
---------------------------------------------------------------------------------</code></pre><p>**　在给出的逻辑运算符之中非运算的理解可以说是最简单的了，因为仅仅是进行了布尔求反而已**</p>
<p><em>范例：观察与逻辑</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        int x = 1;
        int y = 1;
        System.out.println(x == y &amp; 2 &gt; 1);
        System.out.println(x == y &amp; 2 &lt; 1);


    }
}</code></pre><blockquote>
</blockquote>
<p>true<br>false</p>
<p>**　　与的概念虽然很好理解，但是在java里面却针对于逻辑操作提供有两种不同的运算“&amp;”、“&amp;&amp;”，那么这两种运算有什么区别呢。**</p>
<p>范例：观察普通与存在的问题</p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        // 按照高等数学的逻辑来理解“数字/0 = 无求大（计算机的设计来讲无求大意味着内存占满）”
        System.out.println((1 &gt; 2) &amp; 10 / 0 ==0);



    }
}</code></pre><blockquote>
</blockquote>
<p>Exception in thread “main” java.lang.ArithmeticException: / by zero<br>        at DongJun.main(DongJun.java:7)</p>
<p>*这个时候的程序出错实际上意味着所有的判断条件都执行了，但是现在来分析一个问题：对于与操作的逻辑来讲，最大的特点是若干个判断条件如果有一个条件为False，那么最终的与逻辑的结果全部为false（中间出现多少个true都没有意义了）。 *</p>
<pre><code>如果现在使用的是“&amp;”操作意味要全部判断
想要解决程序逻辑判断的性能问题，最佳做法就是使用短路与进行操作。</code></pre><p><strong>范例：短路与进行操作</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        // 按照高等数学的逻辑来理解“数字/0 = 无求大（计算机的设计来讲无求大意味着内存占满）”
        System.out.println((1 &gt; 2) &amp;&amp; 10 / 0 ==0);
        //第一个判断条件（1&gt;2）结果为false，后面的判断没有意义了直接停止判断，返回false




    }
}</code></pre><blockquote>
<p>false</p>
</blockquote>
<p><strong>范例：观察普通或</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        // 按照高等数学的逻辑来理解“数字/0 = 无求大（计算机的设计来讲无求大意味着内存占满）”
        System.out.println((1 == 2) | (10 / 0 ==0));
        //第一个判断条件（1&gt;2）结果为false，后面的判断没有意义了直接停止判断，返回false




    }
}</code></pre><blockquote>
</blockquote>
<p>Exception in thread “main” java.lang.ArithmeticException: / by zero<br>        at DongJun.main(DongJun.java:7)</p>
<p><em>范例：使用短路或</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        // 此时的变量的定义规则为：第一个单词的字母全部小写，随后每一个单子的首字母大写
        //Java中类的定义规则：每一个单词的首字母必须大写
        // 按照高等数学的逻辑来理解“数字/0 = 无求大（计算机的设计来讲无求大意味着内存占满）”
        System.out.println((1 == 1) || (10 / 0 ==0));
        //第一个判断条件（1&gt;2）结果为false，后面的判断没有意义了直接停止判断，返回false




    }
}</code></pre><blockquote>
<p>true</p>
</blockquote>
<pre><code>经过以上分析可以得到一个结论，考虑到执行性能的问题，一定要使用短路与、短路或进行若干操作。</code></pre><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><pre><code>为了提升程序的数据处理性能，在任何的语言里面都提供有位运算符，在很多的项目开发之中一般的开发人员很难见到位运算具体的操作（大部分的位运算都出现在一些比较底层的开发过程之中），java中支持的位运算的类型有：&amp;（位与）、|（位或）、^（异或）、~（反码）、&lt;&lt;（左移）、&gt;&gt;（右移）、&gt;&gt;&gt;（无符号右移）。

如果要想使用位运算，处理的逻辑为：数字除2取余，一直除0为止，最后将所有的余数倒叙取出，下面来分析一下如何将十进制的13数字转为二进制。

面试题：请解释“&amp;”和“&amp;&amp;”的区别？
    - 对于“&amp;&amp;”主要应用在逻辑运算中，表示短路与操作，在进行若干个条件判断的时候，如果有条件返回了false，那么后续的条件都不判断，最终的判断的结果就是false；
    - 对于“&amp;”有两种使用环境：
        |- 逻辑运算：表示所有的判断条件都会执行，不管是否遇见有返回false的判断条件；
        |- 位运算：表示进行位与的计算，如果两位的内容都是1结果才是1，如果有一位是0，那么位与的结果就是0；</code></pre><h1 id="程序的逻辑结构"><a href="#程序的逻辑结构" class="headerlink" title="程序的逻辑结构"></a>程序的逻辑结构</h1><pre><code>|- 实际上程序本身是有自己完善的逻辑性，而且从程序设计角度来讲，程序的逻辑一共分为三种逻辑：顺序结构、分支结构、循环结构。
|- 在面对程序的时候后我们就相当于“程序的上帝”，你规定了某一个程序的功能，某一个程序的处理的逻辑，所谓的程序逻辑就相当于通过自己的想法，为程序规划路线。</code></pre><h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><pre><code>所有的程序都有可能根据一些内容动态的判断是否要执行某些代码，这样的处理逻辑就称为分支逻辑，在程序的开发之中分支逻辑分为两种类型：if分支（逻辑条件判断）、switch开关语句（数值判断）。</code></pre><h2 id="if-分支结构"><a href="#if-分支结构" class="headerlink" title="if 分支结构"></a>if 分支结构</h2><pre><code>if如果直接翻译为中文的话为“如果”的含义，在使用if语句进行判断的会说话必须判断是布尔型的处理结构，针对if语句有如下是那种操作结构：
|- if (布尔表达式) { 
    当布尔表达式成立时执行语句
}

|- if (布尔表达式) { 
    当布尔表达式成立时执行语句
} else {
    条件不满足时执行语句
}

|- if (布尔表达式) { 
    当布尔表达式成立时执行语句
} else if (布尔表达式){
    当布尔表达式成立时执行语句
}……else{
    条件不满足执行
}</code></pre><p><strong>范例：学生成绩分支</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        double score = 190.00 ;
        if (score &gt;= 90.00 &amp;&amp; score &lt;= 100)
        { 
            System.out.println(&quot;优等生&quot;);
        } else if (score &gt;= 60 &amp;&amp; score &lt; 90)
        {
            System.out.println(&quot;良等生&quot;);
        } else {
            System.out.println(&quot;差等生&quot;);
        }
    }
}</code></pre><h2 id="Switch-开关语句"><a href="#Switch-开关语句" class="headerlink" title="Switch 开关语句"></a>Switch 开关语句</h2><pre><code>Switch是一个开关语句，在switch之中它能够判断的数据类型仅仅是：整数、字符、JDK1.5之后追加了枚举，JDK1.7之后追加了String的判断支持，如果要想使用switch必须结合case、default（不是必须）来一起使用，其基本的语法结构如下
|- switch (整数|字符|枚举|String){
    case 匹配内容：
        内容满足时执行的语句;
        [break ;]}
    case 匹配内容:{
        内容满足时执行的语句;
        [break ;]},……[
    default:{
        内容都不满足时执行;
        [break ;]}
    ]
    }</code></pre><p><strong>对于switch来讲，它无法像if语句那样使用逻辑表达式进行判断，仅仅支持数值操作</strong></p>
<p><em>范例：观察switch语句</em></p>
<p>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        int ch = 3;<br>        switch(ch) {<br>            case 1:<br>                System.out.println(“【1】匹配的数字1”);<br>                break ;<br>            case 2:<br>                System.out.println(“【2】匹配的数字2”);<br>                break;<br>            default:<br>                System.out.println(“【NO】无法匹配内容”);<br>                break;</p>
<pre><code>        }
}</code></pre><p>}</p>
<blockquote>
<p>【NO】无法匹配内容</p>
</blockquote>
<blockquote>
<p><em>*　　以上的程序的处理结构是在实际的开发之中使用switch最为常见的结构形式，但是在使用的过程之中，也有可能出现一些认识上的问题，导致最终程序的执行结果与预期有所差别，下面针对于switch中出现一些情况进行说明。**<br>*|- 在编写switch语句的过程之中每一次case语句中都会包含一个“break”，这个语句的含义是阻止其他功能执行</em><br><em>|- 不一定按照顺序来写case</em><br><em>|- 在早期的switch语句结构之外，除了数字之外最主要的支持就是字符了，（因为字符可以和整型自动互相转换）</em></p>
</blockquote>
<pre><code>在JDK1.7之后（是Oracle收购SUN之后的第一个版本）支持有String的判断，但是仅仅是进行完整的判断。</code></pre><p><strong>范例：在switch语句中使用String</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        String message = &quot;我&quot;;
        switch(message){
            case &quot;Dong&quot;:
                    System.out.println(message+&quot;Jun&quot;);
                    break;
            case &quot;董&quot;:
                    System.out.println(message+&quot;俊&quot;);
                    break;
            default:
                    System.out.println(&quot;请输入正确的姓名&quot;);
                    break;

            }
    }
}</code></pre><blockquote>
<p>这种字符串与switch结合匹配主要使用的形式是全匹配。</p>
</blockquote>
<h1 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h1><pre><code>yield是在JDK13之后正式加入到java中的新关键字，这个关键字的主要作用是进行内容的局部返回，现阶段其主要的设计是结合switch语句来使用，下面在正式的讲解yield之前首先观察一个程序</code></pre><p><strong>范例：观察switch分支</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        String data = &quot;one&quot;;
        int result = 0 ;
        switch (data){
            case &quot;one&quot;:
                result = 1;
                break;
            case &quot;two&quot;:
                result = 2;
                break;
            default:
                result = -1;
                break;
        }
        System.out.println(result);


    }
}</code></pre><blockquote>
<p>1</p>
</blockquote>
<blockquote>
<p>*　本程序的核心含义是通过switch的判断来最终决定result变量内容是什么，以上的程序开发是属于传统的做法，而传统的做法现在就觉得有些啰嗦，如果可以直接在switch里面返回数据该多好呢？*</p>
</blockquote>
<p><strong>范例：观察JDK13之后的新结构</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        String data = &quot;one&quot;;
        int result = switch (data){
            case &quot;one&quot; : yield 1 ;
            case &quot;two&quot; : yield 2 ;
            default :{
                yield -1;
                } 
        };
        System.out.println(result);
    }
}</code></pre><blockquote>
<p>1</p>
</blockquote>
<p>*　　以上的做法实际上是局部的switch返回的简化的处理形式，如果现在不想使用“-&gt;”标记符号组合，就可以通过yield关键字来处理了*</p>
<p><strong>该程序的机制实际上并没有完全的加入到java的正规使用的环境之中，还只是一种当前现阶段的测试应用环境，如果要想使用这样的功能就必须在编译和执行的时候追加“–enable-preview”参数</strong></p>
<pre><code>知识结构扩展：python语言里面有yield关键字
    |-在python中的yield也是实现了局部返回，但是它在进行局部返回的时候可以结合生成器和多协程开发进行操作。</code></pre><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><pre><code>在java里面循环的结构分为两类：while循环、for循环，这两种循环在实际的项目开发过程之中基本上都要使用到，而且循环的结构几乎所有的项目中全部都存在。</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code>while 是一种条件判断的循环处理，它主要是针对于给定的条件，当条件满足之后才会执行。</code></pre><p><strong>范例：实现”1-100”数字累加</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int sum = 0 ;
        int num = 1 ;
        while (num &lt;= 100) 
        {
            sum +=num;
            num ++ ;
        }
        System.out.println(&quot;sum=&quot;+sum);
    }
}</code></pre><blockquote>
<p>sum=5050</p>
</blockquote>
<p>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        int sum = 0 ;<br>        int num = 1 ;<br>        do<br>        {<br>            sum +=num;<br>            num++ ;<br>        }<br>        while(num&lt;=100);<br>        System.out.println(“sum=”+sum);<br>    }<br>}</p>
<blockquote>
<p>sum = 5050</p>
</blockquote>
<pre><code>如果真的在实际的项目开发过程之中，很难见到“do……while”循环结构，在代码里面基本上只要条件的循环都以while循环结构为主。</code></pre><h2 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h2><pre><code>如果说你已经明确知道了循环次数的时候，就可以通过for循环结构更加简单的进行循环处理，首先来观察一下for循环的语法结构
|-
  for(循环初始化条件 ; 循环判断 ; 循环条件变更){
    循环体;
  }

      可以发现在for语句结构里，将所有的循环有关的操作全部放在了一行语句完成。</code></pre><p><em>范例：使用for循环</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int sum = 0;
        for (int num = 1; num &lt;= 100 ; num ++ )
        {
            sum += num;
        }
        System.out.println(&quot;sum=&quot;+sum);
        }
}</code></pre><blockquote>
<p>sum = 5050</p>
</blockquote>
<p>**　　需要特别引起注意的一件事情在于：对于for循环结构实际上可以拆开编写，但是在实际的开发过程中不建议如此定义**<br><strong>范例：不便方式</strong><br>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        int sum = 0;<br>        int num = 1;<br>        for (; num &lt;= 100 ; )<br>        {<br>            sum += num;<br>            num ++ ;<br>        }<br>        System.out.println(“sum=”+sum);<br>        }<br>}</p>
<blockquote>
<p>以上的程序代码在实际上开发中不建议使用</p>
</blockquote>
<pre><code>while循环：当不知道明确的循环次数，但是却明确知道循环的结束条件的情况下可以使用while循环；
for循环：明确的知道循环次数的时候使用。</code></pre><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><pre><code>在正常的情况下，所有的循环一旦开启了，那么肯定会按照既定的原则持续的执行下去（一直到不满足循环条件为止，循环才会自动的退出），但是在某些情况下，有可能会阻塞循环的执行。
针对于中断执行提供有两个关键字：continue、break;</code></pre><p><strong>结论：continue结束一次循环调用，而break是退出整个循环结构</strong></p>
<h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><pre><code>大部分的结构都是可以嵌套的，例如：在switch里面可以继续嵌套循环或者是if语句，在循环结构里面也可以嵌套if结构，那么同期，一个循环内部也一定可以嵌套另外一个循环。</code></pre><blockquote>
<p>**　　关于循环嵌套的提醒：只要你能够编写循环，就可以正常的向后学习课程内容。**</p>
</blockquote>
<p><strong>范例：打印乘法口诀表</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        for (int x = 1; x &lt;= 9  ; x ++ )
        {
            for (int y = 1; y &lt;= x ; y ++)
            {
                System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+(x*y)+&quot;\t&quot;);
            }
            System.out.println();
        }
    }
}</code></pre><blockquote>
</blockquote>
<p>1<em>1=1<br>1</em>2=2   2<em>2=4<br>1</em>3=3   2<em>3=6   3</em>3=9<br>1<em>4=4   2</em>4=8   3<em>4=12  4</em>4=16<br>1<em>5=5   2</em>5=10  3<em>5=15  4</em>5=20  5<em>5=25<br>1</em>6=6   2<em>6=12  3</em>6=18  4<em>6=24  5</em>6=30  6<em>6=36<br>1</em>7=7   2<em>7=14  3</em>7=21  4<em>7=28  5</em>7=35  6<em>7=42  7</em>7=49<br>1<em>8=8   2</em>8=16  3<em>8=24  4</em>8=32  5<em>8=40  6</em>8=48  7<em>8=56  8</em>8=64<br>1<em>9=9   2</em>9=18  3<em>9=27  4</em>9=36  5<em>9=45  6</em>9=54  7<em>9=63  8</em>9=72  9*9=81</p>
<p><strong>此时的程序利用循环嵌套实现</strong></p>
<p><strong>范例：打印正三角形</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int line  = 5 ;//总共输出5行
        for (int x=0 ; x &lt;5 ; x ++)
        {
            for (int y=0 ;y &lt; line - x; y++ )
            {
                System.out.print(&quot; &quot;);//输出空格
            }
            for (int y=0; y &lt;= x  ; y++ )
            {
                System.out.print(&quot;* &quot;);
            }
            System.out.println();
        }

    }
}</code></pre><blockquote>
</blockquote>
<pre><code> *
* *</code></pre><hr>
<hr>
<hr>
<p> <strong>实现了三角形的打印</strong></p>
<pre><code>|- 在现在的项目开发过程里面，如果不是必须的情况下，这种循环的嵌套代码会出现，但是不会出现的很多，而且随着你自己开发经验的累计，那么最终也一定可以熟练掌握。
|- 既然已经存在循环嵌套结构，那么就必须去讨论一下关于continue语句的问题了，在程序的开发语言里面可以发现“C”、“C++”、“Java”语法的结构都是非常类似，在C语言里面提供有了一个“goto”关键字，这种关键字在所有项目开发中都被命令禁止使用的开发关键字，因为会造成程序逻辑结构的混乱，在Java里面将“goto”关键字定义为了未使用到的关键字，如果此时在循环嵌套结构里面你非要进行一种代码跳转的实现，就可以通过continue来完成。</code></pre><p><em>范例：在循环嵌套结构里面使用continue进行跳转</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        point: for (int x = 0; x &lt;3 ; x ++ )
        {
            for (int y=0; y&lt; 3  ;  y++)
            {
                if (x == y)
                {
                    continue point;//代码跳转
                }
                System.out.print(x + &quot;、&quot;);
            }
            System.out.println();
        }
    }
}</code></pre><blockquote>
<p>1、2、2、</p>
</blockquote>
<pre><code>在内部的for循环嵌套结构里面使用了continue实现了无条件的跳转处理操作，所以最终的执行结果就出现了偏差，但是这样的程序逻辑是非常不适合阅读，所以以上的代码形式在开发中尽量不要出现</code></pre><h1 id="方法作用概述"><a href="#方法作用概述" class="headerlink" title="方法作用概述"></a>方法作用概述</h1><pre><code>方法（英文单词“method”）指的是一种可以被重复调用的代码段，如果完全没有学习过编程的概念你就把方法想象为一个功能。例如：只要你会开车，那么给你汽车你就可以直接开走（在你的开车的过程之中可能完全不知道汽车的工作原理）。</code></pre><h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><pre><code>在java里面由于方法是整个程序之中最为重要的结构，所以对于方法的定义本身也是非常繁琐的，为了方便大家理解本次讲解的方法结构，所以将采用如下的定义方式：
--------------------------------------------------------------
public static 方法返回值类型 方法名称（参数类型 变量， 参数类型 变量, ……）
{    
    方法体（本方法所需要实现的功能）;
    [return 返回值;]
}</code></pre><p><strong>特别注意：public static本次讲解的方法指的是主类中定义，并且由主方法直接调用的处理形式</strong></p>
<p><em>方法的定义格式：</em></p>
<blockquote>
<p>　　方法的返回值类型：主要使用的是java数据类型（基本类型、引用类型）、如果没有返回值就使用void定义；<br>　　方法名称在java之中有明确的命名要求：第一个单词的字母小写，而后每一个单词的首字母大写；<br>　　如果方法定义了非Void返回值类型，则可以通过return返回处理结果，如果使用了void，也可以使用return，就不需要返回具体的数据内容了</p>
</blockquote>
<p><strong>定义一个无参且无返回值的方法</strong></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        printMessage();
        printMessage();
    }
    public static void printMessage(){//第一个单词字母小写，后续单词首字母大写
        System.out.println(&quot;******************&quot;) ;
        System.out.println(&quot;******  DJ  ******&quot;) ;
        System.out.println(&quot;******************&quot;) ;
    }                                             
}</code></pre><blockquote>
</blockquote>
<hr>
<p><strong>**</strong>  DJ  <strong>**</strong></p>
<hr>
<hr>
<p><strong>**</strong>  DJ  <strong>**</strong></p>
<hr>
<p><strong>程序之中存在有方法之后，程序代码依旧要通过主方法执行</strong></p>
<p><em>范例：定义一个有参数有返回值的方法</em></p>
<p>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        String result = payAndGet(20.0);<br>        System.out.println(result);<br>        //如果方法本身就存在返回值声明，那么也可以直接进行输出<br>        System.out.println(payAndGet(9.9));</p>
<pre><code>}
public static String payAndGet(double money){
    if(money &gt;= 10.0){
        return &quot;购买一份快餐，找零：&quot;+ (money - 10.0);//返回一个字符串
    }
    else {
        return &quot;对不起，你的余额不足。&quot;;
        }
}                                             </code></pre><p>}</p>
<blockquote>
</blockquote>
<p>购买一份快餐，找零：10.0<br>对不起，你的余额不足。</p>
<p><strong>需要注意的一个问题：如果你现在定义的方法使用了void声明了返回值类型（方法不会返回数据），那么这个时候也可以利用return语句结束当前方法调用（此时的return不应该继续返回任何内容了）</strong></p>
<p><em>范例：使用return结束方法调用</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        sale(3);
        sale(-3);

    }
    public static void sale(int amount){
            if (amount &lt;= 0)//设置一个判断条件
            {
                return ;//后续的语句都不在执行了（相当于break、continue概念）
            }
            System.out.println(&quot;销售出了&quot;+amount+&quot;李兴华&quot;);
        }
    }                                             </code></pre><blockquote>
</blockquote>
<p>销售出了3李兴华</p>
<p><em>return相当于结束当前方法</em></p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><pre><code>方法重载从严格意义上来讲指的是一种方法名称的重用功能，利用特定的处理机制，可以让一个方法实现不同的功能。</code></pre><p>**　　在Java程序里面方法的名称实际上和变量的名称一样，都是不能够重复的，所以如果要进行方法重载的话，那么首先要做的事情就是必须将方法名称设置为相同，但是需要针对于方法的参数进行不同的定义，方法的参数及类型要有所不同。**</p>
<p><strong>范例：观察方法重载</strong></p>
<p>public class DongJun{<br>    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示<br>    public static void main(String DongJun[]){<br>        System.out.println(sum(10, 20));<br>        System.out.println(sum(10, 20, 30));<br>        System.out.println(sum(10.2, 20.3));<br>        }<br>    public static int sum(int x, int y) {<br>        return x + y;<br>    }<br>    public static int sum(int x, int y, int z)//此时定义的sum()方法的名称重复，但是参数的个数不重复<br>    {<br>        return x + y + z;<br>    }<br>    public static double sum(double x, double y) {<br>            return x + y;<br>            }<br>    }</p>
<blockquote>
</blockquote>
<p>30<br>60<br>30.5</p>
<p><em>对于以上的程序代码，本身也存在有一些设计问题</em></p>
<p>**　　在java中进行方法重载的时候只是针对于方法名称和参数的类型及个数有所要求，但是并没有对方法的返回值有所要求，也就是说一个方法被重载之后可以由不同的返回值类型定义，但是这也成为了一个设计上的问题。**</p>
<p><em>为什么需要有方法重载的机制呢？</em></p>
<blockquote>
<p><strong>之所以提供有方法的重载，主要的目的是为了保留方法名称（有些方法名称是拥有公共特征，不应该将其隶属于某一种数据类型）</strong><br>实际上在整个的java里面最具有代表性的一种重载的就属于输出的操作。</p>
</blockquote>
<p><em>范例：观察屏幕输出</em></p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        System.out.println(1);
        System.out.println(1.1);
        System.out.println(&quot;www&quot;);
        System.out.println(&apos;Y&apos;);
        System.out.println(true);



    }
}        </code></pre><blockquote>
</blockquote>
<p>1<br>1.1<br>www<br>Y<br>true</p>
<p><strong>此时可以发现“System.out.println()”(后面有括号全部表示方法调用)可以输出不同的数据类型，所以该方法本身也属于一种重载的方法。</strong></p>
<h2 id="方法递归调用"><a href="#方法递归调用" class="headerlink" title="方法递归调用"></a>方法递归调用</h2><pre><code>方法的递归调用属于一种方法调用的特殊形式，这种方法调用指的是就是一个方法调用自身的情况，但是在进行递归调用过程之中一定要设置好结束条件，否则依然会出现循环的问题。</code></pre><p><strong>范例：通过递归实现一个数字的累加</strong><br>|- “1<del>100”累加，或者是由”1</del>1000”累加，所以这种情况下可以考虑利用递归的模式完成.</p>
<pre><code>public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int sum = 0;
        int num = 1000;
        while (num &gt; 0 )
        {
            sum += num;
            num --;
        }
        System.out.println(sum);

    }
}    

public class DongJun{ 
    static int age; //如果现在没有定义具体的内容，则应该使用默认值“0”来表示
    public static void main(String DongJun[]){
        int result = sum(1000);
        System.out.println(result);
    }
    public static int sum(int num) {
        if (num == 0) {
            return 0;
        }
         return num + sum(num - 1); //递归调用

    }
}                                             </code></pre><blockquote>
<p>500500</p>
</blockquote>
<p><strong>为了便于理解，下面针对于当前给定的sum()递归调用进行一个简单的操作说明：</strong></p>
<pre><code>    【第一次调用】由“main（）”方法发出：return 10000+sum(9999);
    【第二次调用】由“main（）”方法发出：return 9999+sum(9998);
    【倒数第二次调用】由“main（）”方法发出：return 1+sum(0);
    【倒数第二次调用】由“main（）”方法发出：return 0;
由于递归操作较为繁琐，而且一旦处理不当那么就有可能在代码的执行过程之中出现内存溢出的问题（需要一些栈内存支持），所以如果不是必须的情况下尽量不要去编写递归调用（在java开发过程里面实际上你也不会使用递归。）</code></pre><h1 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h1><pre><code>在整个的java（连同C++一样）最为复杂繁琐的部分就是面向对象的编程了，但是如果说现在我们都不知道面向对象的程序结构是什么，而仅仅是进行一些概念上的细分，实际上就属于极为不厚道的讲法。
在编程语言项目的发展历史过程之中，早期的项目设计结构使用的是“面向过程”，面向过程最大的特点是解决当前的问题。
而面向对象是在面向过程之上的进一步的技术发展，面向对象最大的一个特点在于进行标准化的设计，也就是说它在进行项目开发之前一定要对不同层次的功能的整合进行详细的说明。</code></pre><p>**　　面向对象的设计之中，除了拥有模块化的设计结构之外，实际上还有三个重要的特点：**</p>
<blockquote>
</blockquote>
<p>|- 封装性：程序内部的处理结构对外不可见（结构内部不可见、实现结构不可见）;<br>    - 实现结构不可见：不同的层之间进行处理的时候可以完全不知道具体的实现细节；<br>    - 内部结构不可见：内部的相关的核心定义外部无法直接访问，这就与访问权限相关了；<br>|- 继承性：在先人的基础上继续发展，就好比如果参考进化论，每一位人祖先都是猿人，肯定每一代都要比上一代要强，利用继承的结构划分出不同的类关系，同时保证一些公共的特征存留下来。<br>|- 多态性：多态是一种不确定的执行模式，同样的一个功能不同的人干会有不同的方法，但是最终的目的都是在解决核心的问题。</p>
<pre><code>面向对象之中会有许多更加细节化的概念，那么这些概念都需要时间慢慢沉淀，对于面向对象本身并不是世界上唯一使用编程模型，也有许多的开发者愿意使用面向过程或者函数式的编程，而java采用的是面向对象的开发，从本质上来讲这样的代码写起来有些难受（要求的语法结构非常细致），但是最大的特点是易于阅读。</code></pre><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><pre><code>如果要想研究面向对象的编程技术，那么首先一定要明确的就是类与对象的关系，因为这个关系是整个面向对象编程之中基本组成单元，类描述的是一类事物的共同特征的集合（概念是不能够直接使用的），而对象描述的是一个体化拥有鲜明特点的实物。</code></pre><p>**　　在每一个类之中都会有相关的属性和行为（方法)，所谓的行为描述的就是类的功能，所有的对象都可以去调用类中定义的功能。**</p>
<blockquote>
<p><strong>在进行面向对象设计之中一定要先进行类结构的定义，而后才可以拥有具体的对象，对象是可以直接使用的操作；</strong><br><strong>一个类可以产生多个对象，不同的对象拥有各自不同的特点（属性），但是所有的对象都拥有相同的功能（方法）。</strong><br><em>|- 专业描述：类是对象共性的集合，而对象是类的实例，类必须依靠对象实例才可以使用。</em></p>
</blockquote>
<h2 id="类与对象的定义"><a href="#类与对象的定义" class="headerlink" title="类与对象的定义"></a>类与对象的定义</h2><pre><code>在之前所编写的所有的程序代码都是在一个类中进行程序的定义，在之前分析过了“public class”、&quot;class&quot;定义类的基本区别，实际上在java中程序类主要就是通过class关键字进行定义的，所以定义的基础语法结构如下）：
------------------------------------------------
class 类名称 { //遵守命名规则，每个单词的首字母大写
    [访问修饰符] 数据类型 成员属性（变量）;
    [访问修饰符] 数据类型 成员属性（变量）;
        ... ... ...
    [访问修饰符] 返回值类型 方法名称 （参数类型 参数1 ...）{
        本方法处理语句;
        [return [];]
    }
}
------------------------------------------------
一个类中可以同时定义多个成员属性（FIeld）、也可以定义多个方法（Method)，在进行属性定义前出现的“访问修饰符”最终的作用就是实现类的封装性的特点，本次针对于修饰符采用不定义（默认的形式），而方法中出现的访问修饰符统一使用“public”来进行描述。</code></pre><p><strong>范例：定义一个描述图书信息的类</strong></p>
<pre><code>|- 声明并实例化对象： 类名称 对象名称（变量） = new 类名称();
|- 进行分步定义，整个的操作分为两个处理阶段：
    - 声明对象：类名称 对象名称 = null（引用数据类型的默认值）；
    - 实例化对象： 对象名称 = new 类名称（）;</code></pre><blockquote>
<p><strong>当一个类已经产生了实例化对象之后肯定要对类结构进行操作，在java程序里面，对象可以通过两类语法形式使用类：<br>    |- 调用类中的成员属性（Field）：实例化对象.属性= 值；</strong><br>    |- 调用类中的方法（Method）：实例化对象.方法名称();</p>
</blockquote>
<p>范例：声明并实例化对象</p>
<pre><code>class Book
{
    //图书的名称肯定是多位字符
    String title;
    String author;
    //价格一定是一个小数，double的准确性高于float
    double price;
    public void getInfo() { //本次定义getInfo()方法过程之中可以发现没有使用最初讲解方法时的“static”关键字，在之前讲解方法时在主类中定义的，而现在在类中定义的方法主要通过对象来进行调用，所以此时暂时不加static，具体语法后续会有详细解释。
        System.out.println(&quot;图书名称：&quot;+ title + &quot;、图书作者：&quot; + author + &quot;、图书价格:&quot; + price);
    }
}

public class DongJun //主类
{
    public static void main(String avgs[]){
        Book book = new Book();
        book.title = &quot;我的&quot;;
        book.author = &quot;天啊&quot;;
        book.price = 89.6 ; 
        book.getInfo();
    }
}</code></pre><blockquote>
<p>图书名称：我的、图书作者：天啊、图书价格:89.6</p>
</blockquote>
<p><em>*　　此时的程序代码已经可以通过类产生的实例化对象进行类中结构的调用了，实例化对象一旦出现，类的结构就可以进行各种操作的，而本次的操作仅仅是进行了一些属性的设置以及方法的调用**<br>*观察属性默认值</em></p>
<pre><code>class Book
{
    //图书的名称肯定是多位字符
    String title;
    String author;
    //价格一定是一个小数，double的准确性高于float
    double price;
    public void getInfo() { //本次定义getInfo()方法过程之中可以发现没有使用最初讲解方法时的“static”关键字，在之前讲解方法时在主类中定义的，而现在在类中定义的方法主要通过对象来进行调用，所以此时暂时不加static，具体语法后续会有详细解释。
        System.out.println(&quot;图书名称：&quot;+ title + &quot;、图书作者：&quot; + author + &quot;、图书价格:&quot; + price);
    }
}

public class DongJun //主类
{
    public static void main(String avgs[]){
        Book book = new Book();
        book.getInfo();
    }
}</code></pre><blockquote>
<p>图书名称：null、图书作者：null、图书价格:0.0</p>
</blockquote>
<p>**　　现在程序仅仅是进行了book类对象的实例化处理，随后在没有进行属性设置的情况下立即调用getInfo()方法获取对象内容，通过结果可以发现title、author内容全部为null（String 是一个类，类是引用数据类型，默认值就是null）而price的默认值为“0.0”。**</p>
<pre><code>一个类与对象的基本概念已经讲述完毕，同时以上给出的语法结构实际上也属于实际开发过程之中的常规的操作形式了，但是为了帮助大家更好理解面向对象设计与之前概念的联系，下面利用面向对象的设计形式来实现一个正三角形的打印，而这个打印过程里面，将通过属性来保存打印的行数。</code></pre><p><strong>范例：面向对象设计的应用</strong></p>
<pre><code>class Triangle 
{
    int line = 5 ;
    public void paint() {
        for (int x = 0; x&lt; line ; x++)
        {
            for (int y = 0;  y&lt; line - x; y++ )
            {
                System.out.print(&quot; &quot;);
            }
            for (int y = 0 ;y &lt;= x ; y++ )
            {
                System.out.print(&quot;* &quot;);
            }
            System.out.println();
        }
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Triangle tri = new Triangle();
        tri.line = 3;
        tri.paint();
    }
}</code></pre><blockquote>
</blockquote>
<p>   *</p>
<ul>
<li>*</li>
</ul>
<hr>
<p>**　　在之前实现此功能的时候要么就直接在主方法里面进行定义，要么就直接定义有一个方法进行调用，但是现在将与这个图形有关的成员属性（变量）和操作方法混合定义在了一个“Triangle”类里面，从代码管理来讲，结构是非常清晰的。**</p>
<h2 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h2><pre><code>在之前已经为大家讲解过了整个java之中的数据类型划分，而对于数据类型的划分，在Java里面分为两类：基本数据类型（数值的传递操作）、引用数据类型（内存地址的传递，这种引用传递就类似于C、C++之中的指针的概念）</code></pre><p>**　　所有的数据都要保存在内存之中，但是如何可以准确的获取数据，就称为了计算机操作系统本身需要解决的问题，那么经过了长期的发展之后，人们发现应该将内存的功能分为两个部分：**</p>
<blockquote>
</blockquote>
<p>|- 【heap】 堆内存：是保存对象的真实信息；<br>|- 【stack】栈内存：保存的是对象的堆内存的地址；</p>
<blockquote>
<p><strong>对于所有的内存的操作实际上每一位开发者是完全不知情的，所有与内存分配有关的任何操作全部都是由JVM负责完成的，不同的操作系统之中内存分配机制肯定也是不同的，那么最终全部由JVM进行分配</strong></p>
</blockquote>
<pre><code>如果要想进行对象属性或方法的操作，一定要保证存在有实例化对象（开辟了堆内存的对象、或者有堆指向的实例）</code></pre><h2 id="引用传递分析"><a href="#引用传递分析" class="headerlink" title="引用传递分析"></a>引用传递分析</h2><pre><code>Java之中引用数据类型需要内存的支持，所以在进行程序开发的过程之中，内存是可以有多个指向，内存的多个指向指的是不同的栈内存可以指向同一个堆内存。</code></pre><h2 id="垃圾产生分析"><a href="#垃圾产生分析" class="headerlink" title="垃圾产生分析"></a>垃圾产生分析</h2><pre><code>在Java语言里面有一个最为重要的技术特点：垃圾回收（Garbage Collector），所有的数据都要保存在内存之中，但是内存里面也是需要进行顺序式的空间分配，如果要想非常深入的去理解垃圾回收的相关操作，那么就需要先明白垃圾是什么？如何产生的，随后才可以进一步的优化
Java提供有自动的GC回收机制，但是如果你的程序之中产生的垃圾过多，那么也会造成硬件性能的损耗，从而导致程序的执行性能下降，所以最佳的做法是避免垃圾的产生。</code></pre><h2 id="成员属性的私有化"><a href="#成员属性的私有化" class="headerlink" title="成员属性的私有化"></a>成员属性的私有化</h2><pre><code>|- 在面向对象的设计之中有三大主要特征（封装、继承、多态），封装是在面向对象设计之中最为常见的一种概念，但是如果要思想把封装的所有概念都弄明白，则还需要充分的理解继承与多态，本次所讲解的成员属性私有化就是封装的一种基础实现。
|- 按照一般程序的设计思路来讲，如果要想使用类肯定要通过对象，类中一般会提供有属性和方法，那么不同的对象可以进行属性的操作，传统的做法是直接在类的外部由实例化对象直接进行属性的操作。</code></pre><p><strong>范例：使用private关键字定义类中属性</strong></p>
<pre><code>class Book
{
    private String title;
    private String author;
    private double price;
    public void getInfo(){
        System.out.println(&quot;图书标题：&quot;+ title + &quot;\n图书作者：&quot;+ author +&quot;\n图书价格：&quot;+ price);
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Book book = new Book();
        book.title = &quot;成长日记&quot;;
        book.author = &quot;董俊&quot;;
        book.price = 99.9; 
        book.getInfo();



    }
}</code></pre><blockquote>
</blockquote>
<p>DongJun.java:14: 错误: title 在 Book 中是 private 访问控制<br>                book.title = “成长日记”;<br>                    ^<br>DongJun.java:15: 错误: author 在 Book 中是 private 访问控制<br>                book.author = “董俊”;<br>                    ^<br>DongJun.java:16: 错误: price 在 Book 中是 private 访问控制<br>                book.price = 99.9;</p>
<p><strong>使用private关键字定义类中属性所以无法访问</strong></p>
<pre><code>使用了private外部的对象无法直接访问了，但是类的内部是可以进行访问的，于是如果要想进行private私有属性的访问操作，按照Java本身定义规则来讲，就需要编写setter、getter方法来完成 
|- stter：进行属性内容的设置，基本形式:
-------------------------------------------
public void set 属性名称(属性类型 变量){ 属性名称 = 变量}
private String title;
public void setTitle(String t){
    title = t;    
}
|- getter：获取属性内容：基本的形式：
--------------------------------------
public 属性类型 get属性名称(){
    return 属性名称;
}
public String getTitle(){
    return title;
}</code></pre><p><em>你的类中不管有多少属性都需要编写与之匹配的setter、getter</em>的方法的个数，而且这种编写的设计结构是所有的Java后续开发之中都一定会使用的模式。</p>
<p><strong>范例：观察private属性访问</strong></p>
<p>class Book<br>{<br>    private String title;<br>    private String author;<br>    private double price;<br>    public void setTitle(String t){<br>        title = t;<br>    }<br>    public void setAuthor(String a){<br>        author = a;<br>    }<br>    public void setPrice(double p)<br>    {<br>        price = p;<br>    }<br>    public String getTitle(){<br>        return title;<br>    }<br>    public String getAuthor(){<br>        return author;<br>    }<br>    public double getPrice()<br>    {<br>        return price;<br>    }</p>
<p>}<br>public class DongJun //主类<br>{<br>    public static void main(String avgs[]){<br>        Book book = new Book();<br>        book.setTitle(“我行得正”);<br>        book.setAuthor(“做的好”);<br>        book.setPrice(88);<br>        System.out.println(“图书名：”+book.getTitle()+book.getAuthor()+book.getPrice());<br>    }<br>}</p>
<blockquote>
</blockquote>
<p>图书名：我行得正做的好88.0</p>
<pre><code>在日后整个程序的开发过程之中，只要编写类中的属性一定要使用private进行声明，而private声明的属性必须要与之匹配的setter、getter方法才可以被外部所访问，即便当前的代码里面没有调用全部方法，但是作为一个标准类的功能这些方法都是必须提供出来的。</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre><code>构造方法是Java类之中的一种特殊形式的操作方法，其调用的时机是在对象实例化的时候（堆内存开辟的时候进行调用），下面首先来观察一下构造方法的基本形式；</code></pre><p><strong>范例：观察构造方法</strong></p>
<pre><code>class Book
{
    public Book(){//构造方法
        System.out.println(&quot;******董俊来*******&quot;);
    }
}
public class DongJun
{
    public static void main(String args[])
    {
        System.out.println(&quot;【1】声明book类对象：“Book book = null; ”&quot;);
        Book book = null; 
        System.out.println(&quot;【2】实例化book类对象:“book = new Book();”&quot;);
        book = new Book();//实例化对象
    }
}</code></pre><blockquote>
<p>【1】声明book类对象：“Book book = null; ”<br>【2】实例化book类对象:“book = new Book();”</p>
</blockquote>
<p><strong>在整个程序执行过程之中，真正进行构造方法调用的位置处就是使用关键字“new”实例化对象的时候，实际上对于此时的操作，Book类中就定义了构造方法，但是对于构造方法本身是有其非常严格的定义要求的：</strong></p>
<pre><code>|- 构造方法的方法名称不能够任意编写，必须与类名称保持一致；
    - 此时定义的类是类名称是Book,而构造方法的名称使用的是“public Book(){}”;
|- 构造方法没有返回值声明，并且不能够返回任何的数据内容;
|- 一个类之中如果没有定义任何的构造方法，则会在程序编译的时候自动由JDK生成一个无参的构造方法。</code></pre><p><em>构造方法在现实中的应用；</em></p>
<pre><code>|- 构造方法是在使用关键字new的时候才会被调用，而且一个对象只会执行一次构造操作，就好比一个人只能出生一次;
|- 如果现在类中没有通过构造方法进行属性内容的设置，那么就意味着整个的程序在对象实例化之后所有的成员属性都是默认值，那么就需要一步一步的进行属性的配置，就好比书先封装好了，随后再往里面填充内容，最终形成成品。</code></pre><blockquote>
<p>　　<strong>如果现在一个类种即要求有参构造也要求提供无参构造的时候后，唯一可以使用的方法就是通过方法的重载形式来完成，但是需要注意的是，此时只需要考虑方法的参数类型及个数即可（因为构造方法的名称和类名称是完全相同的）</strong></p>
</blockquote>
<p><strong>观察方法的重载</strong></p>
<pre><code>class Book
{
    private String title;
    private String author;
    private double price;
    public Book(){}
    public Book(String t){
        this.setTitle(t);
        this.setAuthor(&quot;沐言优拓&quot;);
        this.setPrice(90.1);
    }
    public Book(String t, String a, double p)
    {
        setTitle(t);
        this.setAuthor(a);
        setPrice(p);
    }
    public void getInfo(){
        System.out.println(&quot;图书标题：&quot;+ title + &quot;\n图书作者：&quot;+ author +&quot;\n图书价格：&quot;+ price);
    }
    public void setTitle(String t){
        title = t;
    }
    public void setAuthor(String a){
        author = a;
    }
    public void setPrice(double p){
        price = p;
    }

}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Book book = new Book(&quot;董俊&quot;,&quot;2&quot;,89.0);
        book.getInfo();
    }
}</code></pre><p><strong>本程序在Book类中定义有三个构造方法：无参构造、单参构造以及三参构造，需要注意的是构造方法本身没有明确的顺序要求，但是考虑到代码的结构性的特点，按照采用参数的降序排列或者升序排列</strong></p>
<p><strong>类中构造方法和类中的普通方法的定义有什么区?</strong></p>
<blockquote>
<p>*　　类的构造方法只在使用关键字new实例化新对象的时候调用一次，而有了实例化对象之后，就可以利用该对象重复的调用类中定义的普通方法。*</p>
<ul>
<li>如果现在构造方法不返回任何数据，那么为什么不能够使用void定义呢？<br>构造方法的名称是由大小写要求的，但是如果仅仅是凭借名称实际上编译器是无法区别构造方法还是普通方法。</li>
</ul>
</blockquote>
<pre><code>如果从方法定义的角度来讲，JDK是依据结构来区分构造或是普通方法的，如果加上了void，实际上就变为了普通方法。</code></pre><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><pre><code>匿名本质上的含义指的就是没有名字，而匿名对象本质上的核心思想就是没有名字的对象。</code></pre><p><em>范例：观察匿名对象的使用</em></p>
<pre><code>class Book {
    private String title;
    private String author;
    private double price;
    public Book(){};    //无参构造方法
    public Book(String t){     //单参构造方法
        this.setTitle(t);
        this.setAuthor(&quot;沐言优拓&quot;);
        this.setPrice(-1.0);
        }
    public Book(String t, String a, double p){
        setTitle(t);
        this.setAuthor(a);
        setPrice(p);
    }
    public void getInfo() {
        System.out.println(&quot;图书名称：&quot;+title+&quot;、图书作者：&quot;+ author + &quot;、图书价格：&quot;+ price);
    }
    public void setTitle(String t){
        title = t;
    }
    public void setAuthor(String a){
        author = a;
    }
    public void setPrice(double p) {
        if (p &gt; 0)
        {
            price = p;
        }
    }
    public String getTitle(){
        return title;
    }
    public String getAuthor(){
        return author;
    }
    public double getPrice(){
        return price;
    }
}
public class YootkDemo{
    public static void main(String args[]){
         new Book(&quot;从入门到时间&quot;,&quot;董俊&quot;,99).getInfo(); // 声明并实例化
         new Book(&quot;从入门到时间&quot;).getInfo();
         new Book().getInfo();
    }
}</code></pre><blockquote>
<p><strong>此时通过关键字new创建的book类的实例化对象，那么就属于一个匿名对象，因为没有对象名称对其进行引用（之前分析了：通过对象名称可以让对象调用多次的操作，如果没有对象名称了，那么该对象就没有引用了，这个对象在使用一次之后就会成为垃圾对象了，那么这个时候有同学可能就不理解了，为什么要有匿名对象呢？）</strong><br><em>现在假设有这样一种生活场景：我是一个卖视频的商铺，因为我的生意非常的火爆，所以我没有时间为我制作的每一件商品命名</em></p>
</blockquote>
<p><strong>范例：使用匿名对象</strong></p>
<pre><code>class Food
{
    private String name;
    private double price;
    public Food(String n, double p){
        name = n;
        price = p;
    }
        //setter、getter略
        public String getInfo(){
            return &quot;名称：&quot;+name + &quot;、价格：&quot; +price;    
        }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        for (int x= 0;x &lt;100  ; x ++ )
        {
            sale(new Food(&quot;西红柿烤烧饼&quot;,7.9);
        }
    }
    public static void sale(Food temp){
        System.out.println(&quot;【卖出商品】&quot;+ temp.getInfo());
    }
}</code></pre><blockquote>
<p><strong>当然，以上的代码也可以使用有名对象，例如：先为food实例化对象命名，随后在通过对象名称进行操作</strong></p>
</blockquote>
<p>​    </p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><pre><code>如果要是以java中的关键字使用为例，个人觉得this关键字是比较繁琐的一个关键字，因为this在程序开发之中使用较为灵活，它可以根据不同的环境而有所改变，而且使用this关键字进行处理操作的过程之中，可以描述是那种处理含义：成员属性、方法（普通方法、构造方法）、表示当前对象。</code></pre><h3 id="this-调用本类成员属性"><a href="#this-调用本类成员属性" class="headerlink" title="this 调用本类成员属性"></a>this 调用本类成员属性</h3><pre><code>在一个类中定义的许多的成员属性都可以互相进行调用，例如：某一个属性可能在构造方法中被调用，那么也可能在普通方法中进行调用，只要是在一个类中那么就都可以实现这样的处理。</code></pre><p><em>范例：观察之前编写过的一个代码</em></p>
<pre><code>class Book
{
    private String title;
    private String author;
    private double price;
    public Book(String t, String a, double p ){
        title = t;
        author = a ;
        price = p ;
    }
    public String getInfo(){
        return &quot;【图书信息】书名：&quot;+this.title + &quot;、作者：&quot;+ this.author + &quot;、价格：&quot;+ this.price;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Book book = new Book(&quot;入门到实战&quot;,&quot;董俊&quot;,90);
        System.out.println(book.getInfo());
    }
}</code></pre><blockquote>
<p>【图书信息】书名：入门到实战、作者：董俊、价格：90.0</p>
</blockquote>
<pre><code>以上的程序代码是在之前经常编写过的程序逻辑，但是对于当前的程序代码里面有一处的设计是非常不合理的，这一处指的就是类中定义的构造方法，来观察一下构造方法的定义：
|- 
    public Book(String t, String a, double p ){
    title = t;
    author = a ;
    price = p ;
    }
这个时候的构造方法里面需要传递有三个参数，并且这三个参数名称使用了单个字母描述，那么请问，如果按照正常的标识符的定义要求来讲，这样的标识符虽然符合语法意义，但是不符合于实际的“明确要求”，因为字母t、a、p可能描述的单词范围太多了，那么这个时候最佳的做法肯定是希望可以写上全部的名称</code></pre><p><em>范例：修改程序实现正确的赋值</em></p>
<pre><code>class Book
{
    private String title;
    private String author;
    private double price;
    public Book(String title, String author, double price ){
        //一旦使用了“this.属性”，那么就永恒描述的是类中的成员耐属性。
        this.title = title;
        this.author = author ;
        this.price = price ;
    }
    public String getInfo(){
        return &quot;【图书信息】书名：&quot;+this.title + &quot;、作者：&quot;+ this.author + &quot;、价格：&quot;+ this.price;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Book book = new Book(&quot;入门到实战&quot;,&quot;董俊&quot;,90);
        System.out.println(book.getInfo());
    }
}</code></pre><blockquote>
<p>【图书信息】书名：入门到实战、作者：董俊、价格：90.0</p>
</blockquote>
<pre><code>在以后编写代码的过程之中，只要是访问本类中的成员属性的操作里面一定要采用“this.属性”的形式进行明确的指派，我曾经个人在编写代码的时候就因为有一个地方少写了 this，最终发现执行的结果缺少内容 ，我排查了好久之后才发现的问题。</code></pre><h3 id="调用本类的普通方法"><a href="#调用本类的普通方法" class="headerlink" title="调用本类的普通方法"></a>调用本类的普通方法</h3><pre><code>在一个类之中往往会存在有大量的普通方法，这些普通方法每当获取了该类的实例化对象之后，那么都可以直接进行调用，而如果要在本类中进行方法调用的时候，理论上直接使用方法名称即可，但是也可以使用&quot;this.方法()&quot;的形式进行更加明确的调用（两者效果相同，但是后者的编写形式更好）。</code></pre><p><strong>范例：观察本类的方法调用</strong></p>
<pre><code>class Book
{
    private String title;
    private String author;
    private double price;
    public Book() {}
    public Book(String title, String author, double price ){
        setTitle(title);
        setAuthor(author);
        setPrice(price); //调用本类方法
    }
    public void set(String title, String author, double price) {
        setTitle(title);
        setAuthor(author);
        setPrice(price); //调用本类方法
    }
    public void setTitle(String title) {
        this.title =  title;
    }
    public void setAuthor(String author){
        this.author = author;
    }
    public void setPrice(double price){
        this.price = price ;
    }
    public String getTitle() {
        return this.title;
    }
    public String getAuthor() {
        return this.author;
    }
    public double getPrice() {
        return this.price;
    }
    public String getInfo(){
        return &quot;【图书信息】书名：&quot;+this.title + &quot;、作者：&quot;+ this.author + &quot;、价格：&quot;+ this.price;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Book bookA = new Book(&quot;入门到实战&quot;,&quot;董俊&quot;,90);
        System.out.println(bookA.getInfo());
        Book bookB = new Book();
        bookB.set(&quot;Python从入门到实战&quot;,&quot;李兴华&quot;,98.8);
        System.out.println(bookB.getInfo());
    }
}</code></pre><blockquote>
</blockquote>
<p>【图书信息】书名：入门到实战、作者：董俊、价格：90.0<br>【图书信息】书名：Python从入门到实战、作者：李兴华、价格：98.8</p>
<pre><code>按照正常的设计思维来讲，类之中的普通方法调用的形式应该为“对象.方法()”，但是如果要是在本类之中调用本类的方法时候可以直接编写方法名称，而如果要想更加明确的描述调用本类方法的话则最好编写的形式为&quot;this.方法()&quot;</code></pre><h2 id="构造方法互调用"><a href="#构造方法互调用" class="headerlink" title="构造方法互调用"></a>构造方法互调用</h2><pre><code>|- 一个类之中构造方法是允许进行重载的，在进行构造方法重载的过程之中只需要考虑方法的参数类型及个数的不同即可，所以一个类里面构造方法可能有很多，那么在这样的环境下就可以考虑利用&quot;this()&quot;的形式实现构造方法的互相调用，这种互相调用的机制也仅仅是使用一次(构造方法只能够调用一次，是在新对象开辟堆内存空间的时候使用)。
|- 既然所有的对象进行实例化的时候都一定会进行构造方法的调用，那么假设说现在类中存在有三个构造方法，分别描述的是无参构造、单参构造、三参构造，那么这个时候不管是调用了那一个构造方法，都可能执行某些操作（输出一些重要的信息），那么按照原始的做法代码有可能定义为如下的形式：</code></pre><p><strong>范例：采用原始的形式实现固定操作的执行</strong></p>
<pre><code>class Book
{
    public Book() { 
        System.out.println(&quot;【对象创建提示】&quot;);//想象为30行代码
        }
    public Book(String title) {//单参
        System.out.println(&quot;【对象创建提示】&quot;);//想象为30行代码
    }
    public Book(String title, String author, double price ){//多参
        System.out.println(&quot;【对象创建提示】&quot;);//想象为30行代码
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
            new Book(&quot;java实战&quot;,&quot;董俊&quot;,89);
            new Book(&quot;java实战&quot;);
            new Book();
        }
}</code></pre><blockquote>
</blockquote>
<p>【对象创建提示】<br>【对象创建提示】<br>【对象创建提示】</p>
<pre><code>此时的程序已经实现了之前提出的开发要求，只要是进行新对象的创建，则一定要进行提示信息的输出，但是这个时候也可以发现一个问题：对于某些操作重复的在代码中出现了，按照之前所讲解的形式，如果要想解决重复，那么一般可以考虑使用方法进行包装，那么只需要每一次调用特定的方法就可以解决重复代码定义问题。</code></pre><p><em>范例：利用方法的形式解决代码重复</em></p>
<pre><code>class Book
{
    public Book() { 
        this.initObject();
        }
    public Book(String title) {//单参
        this.initObject();
    }
    public Book(String title, String author, double price ){//多参
        this.initObject();
    }
    public void initObject() { // 信息提示
        System.out.println(&quot;【对象创建提示】&quot;);//想象为30行代码
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
            new Book(&quot;java实战&quot;,&quot;董俊&quot;,89);
            new Book(&quot;java实战&quot;);
            new Book();
        }
}</code></pre><blockquote>
</blockquote>
<p>【对象创建提示】<br>【对象创建提示】<br>【对象创建提示】</p>
<pre><code>虽然这个时候进行了重复代码的方法定义，并且在构造方法之中通过&quot;this.initObject()&quot;方法执行了重复的代码，但是你也会发现此时的程序代码中也存在有设计问题，会发现不同的构造方法里面调用了同样的方法，实际上这个时候后又是一种重复，那么为了解决当前的这种重复的设计，最佳的做法是直接进行构造方法的互调用</code></pre><p><strong>范例：利用this实现构造方法的互调用</strong></p>
<pre><code>class Book
{
    private String title;
    private String author; 
    private double price;
    public Book() { 
        System.out.println(&quot;【对象创建提示】&quot;);//想象为30行代码
        }
    public Book(String title) {//单参
        this();
        this.title = title;
    }
    public Book(String title, String author, double price ){//多参
        this(title);//调用无参构造
        this.title = title;
        this.author = author;
        this.price = price;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
            new Book(&quot;java实战&quot;,&quot;董俊&quot;,89);
            new Book(&quot;java实战&quot;);
            new Book();
        }
}</code></pre><blockquote>
</blockquote>
<p>【对象创建提示】<br>【对象创建提示】<br>【对象创建提示】</p>
<pre><code>此时利用了&quot;this()&quot;的语法形式实现了类中不用构造方法的互相调用，并且通过具体的操作实现也可以发现，这种结构的确是比方法抽象更加节约对象初始化代码的效果，但是对于当前的这种语法也需要考虑如下几个问题：
|- 使用&quot;this()&quot;调用构造方法处理的时候必须放在构造方法的首行，因为构造方法是在类对象实例化的时候首先调用的，所以其必须放在构造内，而不同的构造方法有可能存在有不同的顺序问题，所以才将其放在首行。
|- 使用构造方法互相调用的时候一定要保留有出口，否则在程序编译的时候就会直接出现递归错误信息，所以这样程序代码在编译的时候就会直接报错。

既然已经清楚了构造方法之间的互相调用，那么下面就可以针对于这种互相调用进行一次实际的应用说明，现在假设说有一个Book类（包含有三个成员属性&quot;title&quot;、“author”、“price”），这个类中会提供有三种构造方法
    — 无参构造：要求图书名称为“木言优拓”，作者为“李兴华”,价格为9988.66;
    — 单参构造：要求接受图书名称，但是默认情况下的作者为“小李老师”,几个5566.88;
    — 三参构造：要求接受全部的三个成员属性的内容。</code></pre><p><strong>先不去考虑重用性设计直接编写原始代码</strong></p>
<pre><code>class Book
{
    private String title;
    private String author; 
    private double price;
    public Book() { 
            this.title = &quot;木言优拓&quot;;
            this.author = &quot;李兴华&quot;;
            this.price = 9988.66;
        }
    public Book(String title) {//单参
            this.title = title;
            this.author = &quot;小李老师&quot;;
            this.price = 5566.88;
        }

    public Book(String title, String author, double price ){//多参
            this.title = title;
            this.author = author;
            this.price = price;

    }
    public String getInfo(){
        return &quot;图书名称:&quot; + this.title + &quot;、图书作者：&quot;+ this.author + &quot;、图书价格:&quot; +this.price;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
            Book bookA = new Book();
            Book bookB = new Book(&quot;从java到入门&quot;);
            Book bookC = new Book(&quot;从python到入门&quot;,&quot;李兴华&quot;,99.8);
            System.out.println(bookA.getInfo());
            System.out.println(bookB.getInfo());
            System.out.println(bookC.getInfo());
        }
}</code></pre><blockquote>
</blockquote>
<p>图书名称:木言优拓、图书作者：李兴华、图书价格:9988.66<br>图书名称:从java到入门、图书作者：小李老师、图书价格:5566.88<br>图书名称:从python到入门、图书作者：李兴华、图书价格:99.8</p>
<pre><code>此时程序已经完成了既定的开发要求，但是也可以明确的发现所有重复的操作代码，那么在这样的情况下就可以考虑利用构造方法的互调用来解决当前的重复操作问题。</code></pre><p><em>解决构造方法中的重复代码</em></p>
<pre><code>class Book
{
    private String title;
    private String author; 
    private double price;
    public Book() { 
            this(&quot;木言优拓&quot;,&quot;李兴华&quot;,9988.66);
        }
    public Book(String title) {//单参
            this(title,&quot;小李老师&quot;,5566.88);
        }

    public Book(String title, String author, double price ){//多参
            this.title = title;
            this.author = author;
            this.price = price;

    }
    public String getInfo(){
        return &quot;图书名称:&quot; + this.title + &quot;、图书作者：&quot;+ this.author + &quot;、图书价格:&quot; +this.price;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
            Book bookA = new Book();
            Book bookB = new Book(&quot;从java到入门&quot;);
            Book bookC = new Book(&quot;从python到入门&quot;,&quot;李兴华&quot;,99.8);
            System.out.println(bookA.getInfo());
            System.out.println(bookB.getInfo());
            System.out.println(bookC.getInfo());
        }
}</code></pre><blockquote>
</blockquote>
<p>图书名称:木言优拓、图书作者：李兴华、图书价格:9988.66<br>图书名称:从java到入门、图书作者：小李老师、图书价格:5566.88<br>图书名称:从python到入门、图书作者：李兴华、图书价格:99.8</p>
<pre><code>构造方法的主要作用是进行成员初始化操作，但是在成员属性初始化的过程之中难免会存在有重复的初始化的操作代码，所以这个时候利用构造方法来解决是最合理的一种做法。</code></pre><h2 id="this-表示当前对象"><a href="#this-表示当前对象" class="headerlink" title="this 表示当前对象"></a>this 表示当前对象</h2><pre><code>经过了之前一系列分析可以发现，对于this有一个最为常见的调用类结构的操作形式：“this.成员属性”、“this.方法()”，那么根据在之前所学习的概念来讲，类中的属性或方法可以调用的只能够是实例化对象（如果使用了没有实例化的对象，则一定会出现“NullPointerException”），所以之前的语法之中的this本质上描述的就是一个对象，但是这个对象不是一个固定的对象，而是描述的当前对象概念。
    一般的拥有浪漫气息的节日里面，酒店或者一些客房的预订最为繁华的，例如：红色情人节需要准备，如果是白色情人节也可以准备，如果是浪漫的圣诞结更需要准备。</code></pre><p><strong>如果要想观察出程序里面的当前对象，最简单的做法就是直接进行this关键字的输出，默认情况下每一个实例化对象的输出应该得到的就是一个对象的编码</strong></p>
<p><em>观察实例化对象的直接输出</em></p>
<pre><code>class Book{}
public class DongJun //主类
{
    public static void main(String avgs[]){
            Book bookA = new Book();
            System.out.println(&quot;【main()方法】 = &quot; + bookA);
            Book bookB = new Book();
            System.out.println(&quot;【main()方法】 = &quot; + bookB);
    }
}</code></pre><blockquote>
</blockquote>
<p>【main()方法】 = Book@63961c42<br>【main()方法】 = Book@65b54208</p>
<pre><code>Java中的类属于引用数据类型，引用数据类型之中需要去考虑堆栈的引用关系,发现如果直接进行对象的输出所获得的就是一个对象的编码，而这种编码的格式为“类名称@编码”（这个是由Java内部默认决定的程序结构）。</code></pre><p><strong>范例：观察this与对象的关联</strong></p>
<p>class Book{<br>    public void print() {<br>        System.out.println(“【Book类-print()方法】”+this);<br>    }<br>}<br>public class DongJun //主类<br>{<br>    public static void main(String avgs[]){<br>            Book bookA = new Book();<br>            System.out.println(“【main()方法】 = “ + bookA);<br>            bookA.print();<br>            System.out.println(“—————-   防止   —————- “);<br>            Book bookB = new Book();<br>            System.out.println(“【main()方法】 = “ + bookB);<br>            bookB.print();<br>    }<br>}</p>
<blockquote>
</blockquote>
<p>【main()方法】 = Book@63961c42<br>【Book类-print()方法】Book@63961c42<br>—————-   防止   —————-<br>【main()方法】 = Book@65b54208<br>【Book类-print()方法】Book@65b54208</p>
<p><strong>范例：使用this实现引用传递</strong></p>
<pre><code>class Message 
{
    private String title;
    private String content;
    private Channel channel;
    public Message(Channel channel, String title, String content){
        this.title = title;
        this.content= content;
        this.channel = channel;
    }
    public void send() {
        if (this.channel.connect())
        {
            System.out.println(&quot;【Message】消息发送，消息标题：&quot;+ this.title + &quot;、消息内容：&quot; + this.content);
            this.channel.close();
        } else {
            System.out.println(&quot;【Message】没有可用的消息发送通道，消息发送失败&quot;);
        }
    }
}
class Channel
{
    private Message message;
    public Channel(String title, String content){
        this.message = new Message(this, title, content);
        this.message.send();
    }
    public boolean connect() {
        System.out.println(&quot;【Channel】建立消息信息的发送通道&quot;);
        return true;
    }
    public void close() {
        System.out.println(&quot;【Channel】关闭消息信息的发送通道&quot;);
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Channel channel = new Channel(&quot;木言优拓在线教育&quot;,&quot;编程训练营&quot;);
    }
}</code></pre><blockquote>
</blockquote>
<p>【Channel】建立消息信息的发送通道<br>【Message】消息发送，消息标题：木言优拓在线教育、消息内容：编程训练营<br>【Channel】关闭消息信息的发送通道</p>
<pre><code>现在是在Channel类里面实例化了Message类的独享，所以这个时候如果直接出现有&quot;this&quot;，那么所描述的就是当前channel的对象。</code></pre><h2 id="简单Java类"><a href="#简单Java类" class="headerlink" title="简单Java类"></a>简单Java类</h2><pre><code>在整个的Java技术学习过程之中，首先一定要明确一个核心的问题：学习一门语言如果要想尽快的上手开发，那么就必须熟练的掌握一些核心的编程模型（数学公式），只要遇见了相似的程序按照公式的形式直接定义好即可。
本次重点来研究关于简单Java类的定义，实际上从项目的开发角度来讲，使用类有一个最为核心的功能，它能够描述有一类群体的共性特征。
简单Java类指的是一个类之中主要由属性以及setter、getter方法所组成的类，这个类不牵扯到各种复杂的运算逻辑，仅仅是进行相关数据的存储，同时这种类一般都有明确的实物类型，例如：定义一个描述部门的信息类、定义一个描述雇员的信息类、定义一个描述教师的程序类。
在Java里面随着技术学习的不断深入，你会慢慢更加深刻的了解简单java类的实际使用，包括一些设计上的不断的改良，但是对于现在来讲，给出如下的简单java类的开发要求：
|- 【必选】类名称一定要有意义，可以明确的描述某一类的事物特征；
|- 【必选】类之中所有的属性都必须使用private封装;
|- 【必选】如果要进行属性点设置或者是修改则一定要通过setter方法完成，而属性的获取要通过getter;
|- 【必选】类之中可以定义若干个构造方法，但是一定要提供有一个无参构造方法（需要通过反射机制研究）;
|- 【必选】对象中的所有信息不允许直接在类中使用&quot;System.out.println()&quot;输出,所有的输出内容一定要返回给被调用处来进行输出处理
|- 【可选】类中要提供有一个返回对象信息的处理方式;</code></pre><p><strong>范例定义一个描述部门信息的简单java类</strong></p>
<blockquote>
</blockquote>
<pre><code>|- 假设现在部门信息里面需要包含有部门编号、名称以及位置三个核心属性。

class Dept
{
    private long deptno ; 
    private String dname;
    private String loc;
    public Dept(){}
    public Dept(long deptno, String dname, String loc ){
        this.deptno=deptno;
        this.dname= dname;
        this.loc = loc ;
    }
    public void setDeptno(long deptno){
        this.deptno=deptno;
    }
    public void setDname(String dname){
        this.dname = dname;
    }
    public void setLoc(String loc){
        this.loc = loc ;
    }
    public long getDeptno()
    {
        return this.deptno;
    }
    public String getDname(){
        return this.dname;
    }
    public String getLoc(){
        return this.loc;
    }
    public String getInfo() {
        return &quot;【部门】部门编号：&quot; + this.deptno + &quot;、部门名称：&quot; + this.dname  + &quot;、部门位置：&quot; + this.loc;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Dept dept = new Dept(10, &quot;沐言有哦&quot; , &quot;北京&quot;);
        System.out.println(dept.getInfo());
    }
}</code></pre><blockquote>
</blockquote>
<p>【部门】部门编号：10、部门名称：沐言有哦、部门位置：北京</p>
<pre><code>对于此时的Dept类功能非常的单一，就是进行了数据的保存以及数据的获取，所以这个类不涉及到任何的运算逻辑，就被开发中称为简单java类。</code></pre><blockquote>
<pre><code>重要提示：简单java类是最基础的模型，但是其可以考察以及覆盖的知识点是非常全面的
    |- 类的基本组成：属性、方法（构造方法、普通方法）；
    |- 数据类型的选择：基本类型、引用类型（后面会有更加深入的分析）;
    |- 构造方法的重载；
    |- 属性的封装有以及setter、getter方法的定义要求；
    |- 字符串的连接操作。</code></pre></blockquote>
<h2 id="类与对象实例分析"><a href="#类与对象实例分析" class="headerlink" title="类与对象实例分析"></a>类与对象实例分析</h2><pre><code>面向对象是所有初学者学习的难点，实际上在我个人学习的过程之中，对于面向对象想起来都觉得头大，因为其所涉及的概念是非常的多的，有其实很多的同学学到现在的时候就会突然发懵：不知道什么时简单java类，什么又不是简单java类，针对于这样的情况，本次为大家分析三道程序案例。</code></pre><h3 id="地址类"><a href="#地址类" class="headerlink" title="地址类"></a>地址类</h3><blockquote>
<p><strong>问题一：编写并测试一个代表地址的Address类，地址信息由国家、省份、城市、街道、邮编组成，并可以返回完整地址信息。</strong></p>
</blockquote>
<pre><code>对于此时的设计开发要求本身并没有过多的繁琐，因为在之前所编写的图书类、部门类等等都与该类的结构非常的相似，所以这种类严格来讲就属于一个简单java类

class Address 
{
    // 属性private封装
    private String country;
    private String province;
    private String city;
    private String street;
    private String zipcode;
    public Address(){}
    public Address(String country, String province, String city, String street, String zipcode)
    {
        this.country = country;
        this.province = province;
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
    public String getInfo(){
        return &quot;【Address】国家：&quot;+ this.country +&quot;、省份：&quot; + this.province + &quot;、城市：&quot; + this.city + &quot;、街道:&quot;+ this.street + &quot;、邮编:&quot;+ this.zipcode;
    }
    public void setCountry(String country){
         this.country = country;
    }
    public void setProvince(String province){
        this.province = province;
    }
    public void setCity(String city){
        this.city = city;
    }
    public void setStreet(String street){
        this.street = street;
    }
    public void setZipcode(String Zipcode){
        this.zipcode = zipcode;
    }
    public String getCountry(String country){
        return this.country;
    }
    public String getProvince(String province){
        return this.province;
    }
    public String getCity(String city){
        return this.city;
    }
    public String getStreet(String street){
        return this.street;
    }
    public String getZipcode(String zipcode){
        return this.zipcode;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Address addr = new Address(&quot;中国&quot;,&quot;湖北&quot;,&quot;武汉&quot;,&quot;新洲区&quot;,&quot;00000&quot;);
        System.out.println(addr.getInfo());
    }
}</code></pre><blockquote>
<p>【Address】国家：中国、省份：湖北、城市：武汉、街道:新洲区、邮编:00000</p>
</blockquote>
<pre><code>对于这样的程序开发啊，其本身属于简单java类，如果连这样的基本程序都不能够保证一次性写对（可以快速的修改正确），那么就不建议你使用任何的开发工具进行代码编写</code></pre><h3 id="员工信息类"><a href="#员工信息类" class="headerlink" title="员工信息类"></a>员工信息类</h3><p><strong>定义并测试一个代表员工的Employee类。员工属性包括“编号”、“姓名”、“基本薪水”、“薪水增长率”，还包括计算薪水增长额及计算增长后的工资总额的操作方法。同时在该类中要提供有四个构造方法：</strong><br><em>【无参构造】编号定义为1000，姓名定义为无名氏，其他内容均为默认值；</em><br><em>【单参构造】传递编号，姓名定义为“新员工”，基本薪水为3000.00,薪水增长率为1%；</em><br><em>【三参构造】传递编号、姓名、基本工资、薪水增长率为5%；</em><br><em>【四参构造】所有的属性全部进行传递。</em></p>
<blockquote>
</blockquote>
<p><strong>题目分析：这个程序并不能算是一个完全的简单java类，因为这个类里面包含有一部分的业务处理逻辑（逻辑计算），但是其整体操作结构依然是进行数据的存储。</strong></p>
<p><em>范例：定义并使用员工类</em></p>
<pre><code>class Employee
{
    private long empno ;
    private String ename ;
    private double salary;
    private double rate;
    // setter、getter操作略…… ， 实际代码之中一定要写上这些方法
    public Employee() {
        this(1000, &quot;无名氏&quot;,0.0, 0.0);
    }
    public Employee(long empno) {
        this(empno, &quot;新员工&quot;,3000.00,0.01);

    }
    public Employee(long empno, String ename , double salary ){
        this(empno, ename, salary, 0.05);
    }
    public Employee(long empno, String ename, double salary, double rate){
        this.empno = empno;
        this.ename = ename;
        this.salary = salary;
        this.rate = rate;
    }
    public double salaryIncValue(){
        this.salary  = this.salary * (1 + this.rate) ;
        return this.salary ;
    }
    public String getInfo(){
        return &quot;【Employee】员工编号:&quot;+ this.empno + &quot;、员工姓名:&quot;+ this.ename + &quot;、基本工资:&quot;+ this.salary + &quot;、增长额:&quot; + this.rate;
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        Employee emp = new Employee(9527,&quot;周星星&quot;,5000.0,0.1);
        System.out.println(emp.getInfo());
        System.out.println(&quot;工资增长：&quot;+emp.salaryIncValue());

    }
}</code></pre><blockquote>
<p>【Employee】员工编号:9527、员工姓名:周星星、基本工资:5000.0、增长额:0.1<br>工资增长：5500.0</p>
</blockquote>
<pre><code>本程序虽然核心的组成结构为简单java类，但是这里面却有了一些程序的处理逻辑存在，所以这种情况下，依然要按照简单java类组成原则进行定义，而对于一些逻辑的处理操作方法额外追加即可。</code></pre><h3 id="用户登录逻辑"><a href="#用户登录逻辑" class="headerlink" title="用户登录逻辑"></a>用户登录逻辑</h3><p>  <strong>习题要求：设计一个表示用户的User类，类中的变量有用户名、口令、定义类的3个构造方法（无参、为用户名赋值、为用户名和口令赋值）、获取和设置口令的方法和返回类信息的方法,同时编写一个进行登录验证的处理操作逻辑。</strong></p>
<p><em>题目分析：对于当前的程序逻辑定义类的母的是为了进行用户登录，如果说没有用户登录的验证需求，那么这个时候就是一个纯粹的简单java类，但是发现有了用户登录验证的需求之后，对于当前的程序逻辑就不再是一个简单的存储了。</em></p>
<p><strong>范例：实现用户的登录验证</strong></p>
<pre><code>class User
{
    private String name ;
    private String password;
    public User(){
        this(null,null);
    }
    public User(String name){
        this(name, null);
    }
    public User(String name, String password){
        this.name = name ;
        this.password = password;
    }
    public boolean isLogin(String tempName, String tempPassword) {
        return tempName.equals(this.name) &amp;&amp; tempPassword.equals(this.password);
    }
}
public class DongJun //主类
{
    public static void main(String avgs[]){
        User user = new User(&quot;董俊&quot;,&quot;123&quot;);
        if (user.isLogin(&quot;董俊&quot;,&quot;123&quot;))
        {
            System.out.println(&quot;用户登录成功，可以开始进行程序访问！&quot;);
        } else {
                    System.out.println(&quot;用户登录失败，错误的用户名和密码！&quot;);
        }
    }
}</code></pre><blockquote>
<p>用户登录成功，可以开始进行程序访问！</p>
</blockquote>
<pre><code>此时程序类是一个功能性的操作类，他不再是一个简单java类，因为让其存储的是核心的业务处理逻辑。</code></pre>

        

      
    </div>

      <!-- 相关文章推荐 -->
     

    
    
    

    <div>
          
            
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="/js/src/jquery.min.js"></script>
  <script src="/js/src/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/posts/18.html">JAVASE</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 孤桜懶契 的个人博客">孤桜懶契</a></p>
  <p><span>发布时间:</span>2020年09月21日 - 09:18:27</p>
  <p><span>最后更新:</span>2021年10月20日 - 13:11:07</p>
  <p><span>原始链接:</span><a href="/posts/18.html" title="JAVASE">https://gylq.gitee.io/posts/18.html</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://gylq.gitee.io/posts/18.html"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({
          title: "",
          text: '复制成功',
          icon: "success",
          showConfirmButton: true
          });
    });
    });
</script>


          
    </div>

    

    <div>
      
        <div>
    
        <div class="read-over">-------------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------------</div>
    
</div>

      
    </div>

    
      <div>
        <div class="share_reward">
  <div>坚持原创技术分享，感谢您的支持和鼓励！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="孤桜懶契 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="孤桜懶契 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/" rel="tag"> <i class="fa fa-tag"></i> 知识拓展</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div style="color:rgba(0,0,0,.75);font-size:13px;letter-spacing:4px;margin-bottom:5px;">(&gt;看完记得五星好评哦亲&lt;)</div>
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/9.html" rel="prev" title="MySql表的结构">
                <i class="fa fa-chevron-left"></i> MySql表的结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/7.html" rel="next" title="CLASSPATH环境属性">
                CLASSPATH环境属性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
         <div
  data-weibo-title="分享到微博"
  data-qq-title="分享到QQ"
  data-douban-title="分享到豆瓣"
  class="social-share"
  class="share-component"



  data-disabled="qzone,google+,linkedin"
  data-description="Share.js - 一键分享到微博，QQ空间，腾讯微博，人人，豆瓣...">
   分享到：
</div>


      
    </div>
  </div>


		  </div>
		</div>
	


	

  
    <div class="comments" id="comments">
    </div>
  





	
<script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '23138-1631285680758-213',
        name: '渗透安全团队',
        qrcode: 'https://gylq.gitee.io/cloudimages/img/mmexport1627522419167.jpg',
        keyword: 'vip',
    });
</script>

	</div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image"
                src="/images/qq.png"
                alt="孤桜懶契" />
              </a>
            
              <p class="site-author-name" itemprop="name">孤桜懶契</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">203</span>
                  <span class="site-state-item-name">文章</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">123</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
              <!-- 为Hexo Next主题添加哈林摇特效  -->
              <a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href="javascript:void(0)" onclick="javascript:(function go() {function c() {var e = document.createElement('link');e.setAttribute('type', 'text/css');e.setAttribute('rel', 'stylesheet');e.setAttribute('href', f);e.setAttribute('class', l);document.body.appendChild(e)}function h(){var e = document.getElementsByClassName(l);for(var t = 0; t< e.length; t++){document.body.removeChild(e[t])}}function p(){var e = document.createElement('div');e.setAttribute('class', a);document.body.appendChild(e);setTimeout(function(){document.body.removeChild(e)},100)}function d(e){return{height:e.offsetHeight,width:e.offsetWidth}}function v(i){var s = d(i);return s.height>e &amp;&amp;s.height<n &amp;&amp; s.width>t &amp;&amp;s.width<r}function m(e){var t=e;var n=0;while(!!t){n+=t.offsetTop;t=t.offsetParent}return n}function g(){var e=document.documentElement;if(!!window.innerWidth){return window.innerHeight}else if(e &amp;&amp; !isNaN(e.clientHeight)){return e.clientHeight}return 0}function y(){if(window.pageYOffset){return window.pageYOffset}return Math.max(document.documentElement.scrollTop,document.body.scrollTop)}function E(e){var t=m(e);return t>=w &amp;&amp; t<=b+w}var songs=['https://www.liaofuzhan.com/music/无尽光芒.mp3'];function S(){var e=document.getElementById('audio_element_id');if(e!=null){var index=parseInt(e.getAttribute('curSongIndex'));if(index>songs.length-2){index=0;}else{index++;}e.setAttribute('curSongIndex',index);N();}e.src=i;e.play()}function x(e){e.className+=' '+s+' '+o}function T(e){e.className+=' '+s+' '+u[Math.floor(Math.random()*u.length)]}function N(){var e=document.getElementsByClassName(s);var t=new RegExp('\\b'+s+'\\b');for(var n=0;n<e.length;){e[n].className=e[n].className.replace(t,'')}}function initAudioEle(){var e=document.getElementById('audio_element_id');if(e===null){e=document.createElement('audio');e.setAttribute('class',l);e.setAttribute('curSongIndex',0);e.id='audio_element_id';e.loop=false;e.bgcolor=0;e.addEventListener('canplay',function(){setTimeout(function(){x(k)},500);setTimeout(function(){N();p();for(var e=0;e<O.length;e++){T(O[e])}},15500)},true);e.addEventListener('ended',function(){N();h();go();},true);e.innerHTML='<p>If you are reading this,it is because your browser does not support the audio element. We recommend that you get a new browser.</p><p>';document.body.appendChild(e);}}initAudioEle();var e=30;var t=30;var n=350;var r=350;var curSongIndex=parseInt(document.getElementById('audio_element_id').getAttribute('curSongIndex'));var i=songs[curSongIndex];var s='mw-harlem_shake_me';var o='im_first';var u=['im_drunk','im_baked','im_trippin','im_blown'];var a='mw-strobe_light';var f='https://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css';var l='mw_added_css';var b=g();var w=y();var C=document.getElementsByTagName('*');var k=null;for(var L=0;L<C.length;L++){var A=C[L];if(v(A)){if(E(A)){k=A;break}}}if(A===null){console.warn('Could not find a node of the right size. Please try a different page.');return}c();S();var O=[];for(var L=0;L<C.length;L++){var A=C[L];if(v(A)){O.push(A)}}})()"><i class="fa fa-music"></i> High~</a>

            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="https://github.com/GYLQ/GYLQ.github.io" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="mailto:2324298829@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="https://t.me/GuYingLanQi" target="_blank" title="telegram">
                      
                        <i class="fa fa-fw fa-telegram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="https://mobile.twitter.com/9mGGrn8tDvq6ZhY" target="_blank" title="twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="https://space.bilibili.com/13563835" target="_blank" title="哔哩哔哩">
                      
                        <i class="fa fa-fw fa-apple"></i></a>
                  </span>
                
            </div>
          

            <!--
            <div id="music163player">
                <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1336790004&auto=1&height=66"></iframe>
            </div>
            -->

          
          

          
          

          <!--近期文章版块 began-->
          
              <div class="links-of-blogroll motion-element links-of-blogroll-block">
                <div class="links-of-blogroll-title">
                  <i class="fa fa-history fa-" aria-hidden="true"></i>
                  近期文章
                </div>
                <ul class="links-of-blogroll-list">
                  
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/posts/202.html" title="【漏扫工具】渗透测试常用工具集整理（包含xray、awvs等）" target="_blank">【漏扫工具】渗透测试常用工具集整理（包含xray、awvs等）</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/posts/201.html" title="【应急靶场实践】Ubuntu-暴力破解、写入ssh公钥留后门、植入GPU挖矿程序——事件复现（含靶场环境）" target="_blank">【应急靶场实践】Ubuntu-暴力破解、写入ssh公钥留后门、植入GPU挖矿程序——事件复现（含靶场环境）</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/posts/200.html" title="【渗透靶场实践】Win2008-暴力破解、留后门隐藏账户与shift粘贴键后门、植入WaKuang程序——事件复现（含靶场环境）" target="_blank">【渗透靶场实践】Win2008-暴力破解、留后门隐藏账户与shift粘贴键后门、植入WaKuang程序——事件复现（含靶场环境）</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/posts/199.html" title="【应急靶场实践】Win2008-暴力破解、留隐藏账户后门与shift粘贴键后门、植入WaKuang程序——事件复现（含靶场环境）" target="_blank">【应急靶场实践】Win2008-暴力破解、留隐藏账户后门与shift粘贴键后门、植入WaKuang程序——事件复现（含靶场环境）</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/posts/198.html" title="【渗透靶场实践】Linux-暴力破解、替换ps命令、留多个后门——事件复现（含靶场环境）" target="_blank">【渗透靶场实践】Linux-暴力破解、替换ps命令、留多个后门——事件复现（含靶场环境）</a>
                    </li>
                  
                </ul>
              </div>
          
          <!--近期文章版块 end-->

          
              <!-- canvas粒子时钟 -->
              <!-- canvas粒子时钟 https://www.cnblogs.com/xiaohuochai/p/6368039.html
  https://www.html5tricks.com/html5-canvas-dance-time.html
 -->
<div id="">
  <canvas id="canvas" style="width:60%;">
</div>
<script async>
(function(){
  var WINDOW_WIDTH = 820;
  		var WINDOW_HEIGHT = 250;
  		var RADIUS = 7; //球半径
  		var NUMBER_GAP = 10; //数字之间的间隙
  		var u=0.65; //碰撞能量损耗系数
  		var context; //Canvas绘制上下文
  		var balls = []; //存储彩色的小球
  		const colors = ["#33B5E5","#0099CC","#AA66CC","#9933CC","#99CC00","#669900","#FFBB33","#FF8800","#FF4444","#CC0000"]; //彩色小球的颜色
  		var currentNums = []; //屏幕显示的8个字符
  		var digit =
                  [
                      [
                          [0,0,1,1,1,0,0],
                          [0,1,1,0,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,0,1,1,0],
                          [0,0,1,1,1,0,0]
                      ],//0
                      [
                          [0,0,0,1,1,0,0],
                          [0,1,1,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [1,1,1,1,1,1,1]
                      ],//1
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,0,0,0],
                          [0,1,1,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,0,0,0,1,1],
                          [1,1,1,1,1,1,1]
                      ],//2
                      [
                          [1,1,1,1,1,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,1,0,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//3
                      [
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,1,0],
                          [0,0,1,1,1,1,0],
                          [0,1,1,0,1,1,0],
                          [1,1,0,0,1,1,0],
                          [1,1,1,1,1,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,1,1]
                      ],//4
                      [
                          [1,1,1,1,1,1,1],
                          [1,1,0,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,1,1,1,1,0],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//5
                      [
                          [0,0,0,0,1,1,0],
                          [0,0,1,1,0,0,0],
                          [0,1,1,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,0,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//6
                      [
                          [1,1,1,1,1,1,1],
                          [1,1,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0]
                      ],//7
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//8
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,1,1,0,0,0,0]
                      ],//9
                      [
                          [0,0,0,0],
                          [0,0,0,0],
                          [0,1,1,0],
                          [0,1,1,0],
                          [0,0,0,0],
                          [0,0,0,0],
                          [0,1,1,0],
                          [0,1,1,0],
                          [0,0,0,0],
                          [0,0,0,0]
                      ]//:
                  ];

  		function drawDatetime(cxt){
  			var nums = [];

  			context.fillStyle="#005eac"
  			var date = new Date();
  			var offsetX = 70, offsetY = 30;
  			var hours = date.getHours();
  			var num1 = Math.floor(hours/10);
  			var num2 = hours%10;
  			nums.push({num: num1});
  			nums.push({num: num2});
  			nums.push({num: 10}); //冒号
  			var minutes = date.getMinutes();
  			var num1 = Math.floor(minutes/10);
  			var num2 = minutes%10;
  			nums.push({num: num1});
  			nums.push({num: num2});
  			nums.push({num: 10}); //冒号
  			var seconds = date.getSeconds();
  			var num1 = Math.floor(seconds/10);
  			var num2 = seconds%10;
  			nums.push({num: num1});
  			nums.push({num: num2});

  			for(var x = 0;x<nums.length;x++){
  				nums[x].offsetX = offsetX;
  				offsetX = drawSingleNumber(offsetX,offsetY, nums[x].num,cxt);
  				//两个数字连一块，应该间隔一些距离
  				if(x<nums.length-1){
  					if((nums[x].num!=10) &&(nums[x+1].num!=10)){
  						offsetX+=NUMBER_GAP;
  					}
  				}
  			}

  			//说明这是初始化
  			if(currentNums.length ==0){
  				currentNums = nums;
  			}else{
  				//进行比较
  				for(var index = 0;index<currentNums.length;index++){
  					if(currentNums[index].num!=nums[index].num){
  						//不一样时，添加彩色小球
  						addBalls(nums[index]);
  						currentNums[index].num=nums[index].num;
  					}
  				}
  			}
  			renderBalls(cxt);
  			updateBalls();

  			return date;
  		}

  		function addBalls (item) {
  			var num = item.num;
  			var numMatrix = digit[num];
  			for(var y = 0;y<numMatrix.length;y++){
  				for(var x = 0;x<numMatrix[y].length;x++){
  					if(numMatrix[y][x]==1){
  						var ball={
  							offsetX:item.offsetX+RADIUS+RADIUS*2*x,
  							offsetY:30+RADIUS+RADIUS*2*y,
  							color:colors[Math.floor(Math.random()*colors.length)],
  							g:1.5+Math.random(),
  							vx:Math.pow(-1, Math.ceil(Math.random()*10))*4+Math.random(),
  							vy:-5
  						}
  						balls.push(ball);
  					}
  				}
  			}
  		}

  		function renderBalls(cxt){
  			for(var index = 0;index<balls.length;index++){
  				cxt.beginPath();
  				cxt.fillStyle=balls[index].color;
  				cxt.arc(balls[index].offsetX, balls[index].offsetY, RADIUS, 0, 2*Math.PI);
  				cxt.fill();
  			}
  		}

  		function updateBalls () {
  			var i =0;
  			for(var index = 0;index<balls.length;index++){
  				var ball = balls[index];
  				ball.offsetX += ball.vx;
  				ball.offsetY += ball.vy;
  				ball.vy+=ball.g;
  				if(ball.offsetY > (WINDOW_HEIGHT-RADIUS)){
  					ball.offsetY= WINDOW_HEIGHT-RADIUS;
  					ball.vy=-ball.vy*u;
  				}
  				if(ball.offsetX>RADIUS&&ball.offsetX<(WINDOW_WIDTH-RADIUS)){

  					balls[i]=balls[index];
  					i++;
  				}
  			}
  			//去除出边界的球
  			for(;i<balls.length;i++){
  				balls.pop();
  			}
  		}
  		function drawSingleNumber(offsetX, offsetY, num, cxt){
  			var numMatrix = digit[num];
  			for(var y = 0;y<numMatrix.length;y++){
  				for(var x = 0;x<numMatrix[y].length;x++){
  					if(numMatrix[y][x]==1){
  						cxt.beginPath();
  						cxt.arc(offsetX+RADIUS+RADIUS*2*x,offsetY+RADIUS+RADIUS*2*y,RADIUS,0,2*Math.PI);
  						cxt.fill();
  					}
  				}
  			}
  			cxt.beginPath();
  			offsetX += numMatrix[0].length*RADIUS*2;
  			return offsetX;
  		}

  		var canvas = document.getElementById("canvas");
  		canvas.width=WINDOW_WIDTH;
  		canvas.height=WINDOW_HEIGHT;
  		context = canvas.getContext("2d");

  		//记录当前绘制的时刻
  		var currentDate = new Date();

  		setInterval(function(){
  			//清空整个Canvas，重新绘制内容
  			context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  			drawDatetime(context);
  		}, 50)
})();
</script>

          
          
              <!-- 网站运行时间 -->
              <div id="days"></div>

<script async language="javascript">

  function show_date_time(){
      window.setTimeout("show_date_time()", 1000);
  //    BirthDay=new Date("08/07/2019 20:00:00");
      BirthDay=new Date("07/02/2020 10:00:00");
      today=new Date();
      timeold=(today.getTime()-BirthDay.getTime());
      sectimeold=timeold/1000
      secondsold=Math.floor(sectimeold);
      msPerDay=24*60*60*1000
      e_daysold=timeold/msPerDay
      daysold=Math.floor(e_daysold);
      e_hrsold=(e_daysold-daysold)*24;
      hrsold=setzero(Math.floor(e_hrsold));
      e_minsold=(e_hrsold-hrsold)*60;
      minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
      seconds=setzero(Math.floor((e_minsold-minsold)*60));
      document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"时"+minsold+"分"+seconds+"秒";
  }

  function setzero(i){
      if (i<10)
      {i="0" + i};
      return i;
  }

  show_date_time();

</script>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#程序注释"><span class="nav-number">1.</span> <span class="nav-text">程序注释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标识符"><span class="nav-number">2.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#具体内容"><span class="nav-number">3.1.</span> <span class="nav-text">具体内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量与常量"><span class="nav-number">4.</span> <span class="nav-text">变量与常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#整型"><span class="nav-number">5.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浮点型"><span class="nav-number">6.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符型"><span class="nav-number">7.</span> <span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#布尔型"><span class="nav-number">8.</span> <span class="nav-text">布尔型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-字符串"><span class="nav-number">9.</span> <span class="nav-text">String 字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#var关键字"><span class="nav-number">10.</span> <span class="nav-text">var关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-number">11.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数学运算符"><span class="nav-number">12.</span> <span class="nav-text">数学运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自增与自减运算符"><span class="nav-number">13.</span> <span class="nav-text">自增与自减运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关系运算符"><span class="nav-number">14.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三目运算符"><span class="nav-number">15.</span> <span class="nav-text">三目运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">16.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#位运算符"><span class="nav-number">17.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序的逻辑结构"><span class="nav-number">18.</span> <span class="nav-text">程序的逻辑结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分支结构"><span class="nav-number">19.</span> <span class="nav-text">分支结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-分支结构"><span class="nav-number">19.1.</span> <span class="nav-text">if 分支结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Switch-开关语句"><span class="nav-number">19.2.</span> <span class="nav-text">Switch 开关语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#yield-关键字"><span class="nav-number">20.</span> <span class="nav-text">yield 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#循环结构"><span class="nav-number">21.</span> <span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#while循环"><span class="nav-number">21.1.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for循环结构"><span class="nav-number">21.2.</span> <span class="nav-text">for循环结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环控制语句"><span class="nav-number">21.3.</span> <span class="nav-text">循环控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环嵌套"><span class="nav-number">21.4.</span> <span class="nav-text">循环嵌套</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法作用概述"><span class="nav-number">22.</span> <span class="nav-text">方法作用概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法定义"><span class="nav-number">22.1.</span> <span class="nav-text">方法定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法重载"><span class="nav-number">22.2.</span> <span class="nav-text">方法重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法递归调用"><span class="nav-number">22.3.</span> <span class="nav-text">方法递归调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象概述"><span class="nav-number">23.</span> <span class="nav-text">面向对象概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象"><span class="nav-number">23.1.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象的定义"><span class="nav-number">23.2.</span> <span class="nav-text">类与对象的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象内存分析"><span class="nav-number">23.3.</span> <span class="nav-text">对象内存分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用传递分析"><span class="nav-number">23.4.</span> <span class="nav-text">引用传递分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾产生分析"><span class="nav-number">23.5.</span> <span class="nav-text">垃圾产生分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员属性的私有化"><span class="nav-number">23.6.</span> <span class="nav-text">成员属性的私有化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法"><span class="nav-number">23.7.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名对象"><span class="nav-number">23.8.</span> <span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-关键字"><span class="nav-number">23.9.</span> <span class="nav-text">this 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this-调用本类成员属性"><span class="nav-number">23.9.1.</span> <span class="nav-text">this 调用本类成员属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用本类的普通方法"><span class="nav-number">23.9.2.</span> <span class="nav-text">调用本类的普通方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法互调用"><span class="nav-number">23.10.</span> <span class="nav-text">构造方法互调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-表示当前对象"><span class="nav-number">23.11.</span> <span class="nav-text">this 表示当前对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单Java类"><span class="nav-number">23.12.</span> <span class="nav-text">简单Java类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象实例分析"><span class="nav-number">23.13.</span> <span class="nav-text">类与对象实例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地址类"><span class="nav-number">23.13.1.</span> <span class="nav-text">地址类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#员工信息类"><span class="nav-number">23.13.2.</span> <span class="nav-text">员工信息类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户登录逻辑"><span class="nav-number">23.13.3.</span> <span class="nav-text">用户登录逻辑</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

      

      <!-- 标签云 -->
      <!--
      
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
      <h3 class="widget-title">Tag Cloud</h3>
      <div id="myCanvasContainer" class="widget tagcloud">
          <canvas width="250" height="250" id="resCanvas" style="width=100%">
              <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AU/" rel="tag">AU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWVS/" rel="tag">AWVS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMS/" rel="tag">CMS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSRF/" rel="tag">CSRF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CVE-2021-40444/" rel="tag">CVE-2021-40444</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cobalt-Strike/" rel="tag">Cobalt Strike</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dns%E5%8A%AB%E6%8C%81/" rel="tag">Dns劫持</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EXP%E7%BC%96%E5%86%99/" rel="tag">EXP编写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ettercap/" rel="tag">Ettercap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Form/" rel="tag">Form</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/" rel="tag">Gitee自动部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Google-hack%E8%AF%AD%E6%B3%95/" rel="tag">Google hack语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashcat/" rel="tag">Hashcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json%E5%8A%AB%E6%8C%81/" rel="tag">Json劫持</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/" rel="tag">Kali</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metasploit/" rel="tag">Metasploit</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nmap/" rel="tag">Nmap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E6%B3%A8%E5%85%A5/" rel="tag">SQL注入</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSR/" rel="tag">SSR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSRF/" rel="tag">SSRF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SUID%E6%8F%90%E6%9D%83/" rel="tag">SUID提权</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDF/" rel="tag">UDF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPN/" rel="tag">VPN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPS/" rel="tag">VPS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vulnhub/" rel="tag">Vulnhub</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS/" rel="tag">XSS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XXE/" rel="tag">XXE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xpath%E6%B3%A8%E5%85%A5/" rel="tag">Xpath注入</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aircrack/" rel="tag">aircrack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/burp/" rel="tag">burp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clash/" rel="tag">clash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cracked/" rel="tag">cracked</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/" rel="tag">ctf</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctfshow/" rel="tag">ctfshow</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ew/" rel="tag">ew</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/input/" rel="tag">input</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali%E5%9F%BA%E7%A1%80/" rel="tag">kali基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">list的使用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/msf/" rel="tag">msf</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxychains/" rel="tag">proxychains</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E8%84%9A%E6%9C%AC/" rel="tag">python脚本</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqlmap/" rel="tag">sqlmap</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/w13scan/" rel="tag">w13scan</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E5%AE%89%E5%85%A8/" rel="tag">web安全</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wireshark/" rel="tag">wireshark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wp/" rel="tag">wp</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xray/" rel="tag">xray</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二分搜索树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/" rel="tag">二次开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="tag">代码审计</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/" rel="tag">任意代码执行</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" rel="tag">信息收集</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%8D%E6%9D%80/" rel="tag">免杀</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/" rel="tag">内核提权</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" rel="tag">内网渗透</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" rel="tag">博客搭建</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/" rel="tag">命令执行</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%97%85%E6%8E%A2%E5%B7%A5%E5%85%B7/" rel="tag">嗅探工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" rel="tag">堆排序</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" rel="tag">备忘录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E5%9F%9F%E5%90%8D/" rel="tag">子域名</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">学习记录</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%81%E7%A5%9E%E5%8F%B0/" rel="tag">封神台</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" rel="tag">应急响应</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag">异常</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag">微机原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="tag">快速排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/" rel="tag">成长之路</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/" rel="tag">扫描工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/" rel="tag">指纹识别</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%90%E6%9D%83/" rel="tag">提权</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" rel="tag">插入排序</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/" rel="tag">支付漏洞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" rel="tag">文件上传</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" rel="tag">文件读写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E7%BA%BFwifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/" rel="tag">无线wifi密码破解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" rel="tag">权限维持</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">标签的使用</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97/" rel="tag">模块</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" rel="tag">渗透测试</a><span class="tag-list-count">80</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/" rel="tag">渗透测试基础</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" rel="tag">渗透测试工具</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%AF%E6%BA%90/" rel="tag">溯源</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%89%AB%E5%B7%A5%E5%85%B7/" rel="tag">漏扫工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" rel="tag">漏洞复现</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E5%B7%A5%E5%85%B7/" rel="tag">漏洞工具</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7/" rel="tag">爆破工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98/" rel="tag">版本共存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%91%E6%8E%A7%E8%AE%BE%E5%A4%87/" rel="tag">监控设备</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/" rel="tag">知识拓展</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" rel="tag">知识积累</a><span class="tag-list-count">28</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/" rel="tag">端口转发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%B7%A5%E5%85%B7/" rel="tag">网络攻防工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/" rel="tag">英语四级</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%AE%E8%AE%BA%E6%96%87%E4%B8%87%E8%83%BD%E6%A8%A1%E6%9D%BF/" rel="tag">议论文万能模板</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C%E8%AF%AD%E6%B3%95/" rel="tag">谷歌语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B6%8A%E6%9D%83/" rel="tag">越权</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9C%E6%8E%A7%E5%B7%A5%E5%85%B7/" rel="tag">远控工具</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/" rel="tag">选择排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/" rel="tag">链表实现队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/" rel="tag">链表的增删改查</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98/" rel="tag">靶场实战</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/" rel="tag">验证码绕过</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/" rel="tag">黑客工具</a><span class="tag-list-count">64</span></li></ul>
          </canvas>
      </div>
      </div>
      
      -->
      <!-- 标签云 -->

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
       <i class="fa fa-heartbeat"></i>
  </span>
  <!--
    <span class="author" itemprop="copyrightHolder"> &nbsp;孤桜懶契</span>
  -->
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="Site words total count">275.6k</span>
  
</div>












  <div class="subscribe-box">

  </div>


        
<div class="busuanzi-count">
  <!--
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  -->
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

   

  
  
    
      <span class="site-uv">
        
        我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位朋友，
      </span>
    

    
      <span class="site-pv">
        历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇
        <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      </span>
    
  

</div>








        
      </div>
    </footer>

    
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="60" alpha="0.1"  zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="/js/src/av-min.js"></script>
  <script src="/js/src/Valine.min.js"></script>

  <!-- https://deserts.io/diy-a-comment-system/ -->
  <script type="text/javascript">
    new Valine({
        lang: 'zh-cn',
        admin_email: '2324298849@qq.com', //博主邮箱
        el: '#comments' ,
        appId: 'HzU5gDhBUYHF8QTF8DmbGhjD-gzGzoHsz',
        appKey: 'wp1HNJ17SdpnE0wIFq99eTKH',
        emoticon_url: 'https://cdn.jsdelivr.net/gh/leafjame/cdn/emoji',
       // emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
        emoticon_list: ["大佬.gif","点赞.gif","尴尬.gif","鼓掌.gif","笑哭.gif","害羞.gif","黑人问号.gif","坏笑.gif","惊吓.gif","可爱.gif","抠鼻子.gif","流汗.gif","色.gif","吐血.gif","无奈.gif","huaji.png","liuhanhuaji.png","mojinghuaji.png","coshuaji.png","shounuehuaji.png","jizhi.png","doge.png","chigua.png","motion_1016.png","motion_1012.png","motion_1017.png","f_hufen.png","f_geili.png","f_jiong.png","f_meng.png","f_shenma.png","f_v5.png","c_onef.png","c_onem.png","c_fivem.png","c_oney.png","c_teny.png","c_oy.png","1f60a.png","1f60b.png","1f60d.png","1f60e.png","1f61a.png","1f62d.png","1f601.png","1f602.png","1f605.png","1f606.png","1f607.png","1f618.png","1f630.png","1f631.png","1f632.png","1f633.png","1f63e.png","1f63f.png","1f638.png","1f639.png","zhayanjian.gif","ciya.gif","xieyanxiao.gif","huaixiao.gif","xiaoku.gif","leiben.gif","penxue.gif","hanxiao.gif","baiyan.gif","cahan.gif","fadai.gif","haixiu.gif","haqian.gif","ku.gif","liuhan.gif","OK.gif","qiang.gif","woshou.gif","baoquan.gif","qiudale.gif","se.gif","yinxian.gif","yun.gif","zaijian.gif"],
        placeholder: '&#x270d;&nbsp;写评论',
  });

  <!--点击邮件中的链接跳转至相应评论-->
  if(window.location.hash){
      var checkExist = setInterval(function() {
         if ($(window.location.hash).length) {
            $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
            clearInterval(checkExist);
         }
      }, 100);
   }

  </script>






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





    <script>  function addCount(Counter){var $visitors=$('.leancloud_visitors');var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();Counter('get','/classes/Counter',{where:JSON.stringify({url})}).done(function({results}){if(results.length>0){var counter=results[0]; var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.time+1);Counter('put','/classes/Counter/'+counter.objectId,JSON.stringify({time:{'__op':'Increment','amount':1}})) .fail(function({responseJSON}){console.log('Failed to save Visitor num, with error message: '+responseJSON.error);})}else{ Counter('post','/classes/Counter',JSON.stringify({title:title,url:url,time:1})).done(function(){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(1);}).fail(function(){console.log('Failed to create');});}}).fail(function({responseJSON}){console.log('LeanCloud Counter Error: '+responseJSON.code+' '+responseJSON.error);});}$(function(){$.get('https://app-router.leancloud.cn/2/route?appId='+'HzU5gDhBUYHF8QTF8DmbGhjD-gzGzoHsz').done(function({api_server}){var Counter=function(method,url,data){return $.ajax({method:method,url:'https://'+api_server+'/1.1'+url,headers:{'X-LC-Id':'HzU5gDhBUYHF8QTF8DmbGhjD-gzGzoHsz','X-LC-Key':'wp1HNJ17SdpnE0wIFq99eTKH','Content-Type':'application/json',},data:data});};  const localhost=/http:\/\/(localhost|127.0.0.1|0.0.0.0)/;if(localhost.test(document.URL))return;addCount(Counter);});});</script>

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: 31766,
    el: 'wpac-rating',
    color: 'ff9800'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '/js/src/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  

  

  


  <!-- Tidio 在线联系功能、鼠标点击特效、页面反馈...-->
  


  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script async src="/js/src/anime.min.js"></script>
    <script async src="/js/cursor/explosion.min.js"></script>
  



<script>//禁止右键
function click(e) {
if (document.all) {
if (event.button==2||event.button==3) { alert("欢迎光临寒舍，有什么需要帮忙的话，请与站长联系！谢谢您的合作！！！");
oncontextmenu='return false';
}
}
if (document.layers) {
if (e.which == 3) {
oncontextmenu='return false';
}
}
}
if (document.layers) {
document.captureEvents(Event.MOUSEDOWN);
}
document.onmousedown=click;
document.oncontextmenu = new Function("return false;")
document.onkeydown =document.onkeyup = document.onkeypress=function(){
if(window.event.keyCode == 12) {
window.event.returnValue=false;
return(false);
}
}
</script>


  <script>//禁止F12
function fuckyou(){
//关闭当前窗口(防抽)
window.location="https://github.com/GYLQ"; //将当前窗口跳转置空白页
}

function click(e) {
if (document.all) {
  if (event.button==2||event.button==3) {
alert("欢迎光临寒舍，有什么需要帮忙的话，请与站长联系！谢谢您的合作！！！");
oncontextmenu='return false';
}

}
if (document.layers) {
if (e.which == 3) {
oncontextmenu='return false';
}
}
}
if (document.layers) {
fuckyou();
document.captureEvents(Event.MOUSEDOWN);
}
document.onmousedown=click;
document.oncontextmenu = new Function("return false;")
document.onkeydown =document.onkeyup = document.onkeypress=function(){
if(window.event.keyCode == 123) {
fuckyou();
window.event.returnValue=false;
return(false);
}
}
</script>







 <!-- Hotjar Tracking Code for https://gylq.gitee.io -->
  <script async>
      (function(h,o,t,j,a,r){
          h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
          h._hjSettings={hjid:2656906,hjsv:6};
          a=o.getElementsByTagName('head')[0];
          r=o.createElement('script');r.async=1;
          r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
          a.appendChild(r);
      })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  </script>




  <script src="/js/src/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>






  <script async language="javascript">

    var div = document.createElement("div");
    //插入到自定义的theme-info或者copyright之后
    var copyright = document.querySelector(".theme-info2") || document.querySelector(".copyright");

    function show_run_time(){
        window.setTimeout("show_run_time()", 1000);
      // BirthDay=new Date("03/07/2020 20:00:00");
        BirthDay=new Date("07/02/2020 10:00:00");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));

        // 使用zh-Hans.yml的文字替换
        div.innerHTML = "我已在此等候你 " + "<span style='color: #1890ff'> " + daysold + " </span> 天 <span style='color: #1890ff'>" + hrsold + " </span>时 <span style='color: #1890ff'>" + minsold + " </span>分 <span style='color: #1890ff'>" + seconds + " </span>秒 ";

        document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);

    }
    function setzero(i){
        if (i<10)
        {i="0" + i};
        return i;
    }

    show_run_time();

  </script>




<!-- 旋转魔方 -->

   
      
<style>
    .cube_container {
      width: 50px;
      height: 60px;
      margin: 0 auto;
      position: fixed;
      z-index: 999;
      -webkit-perspective: 1000px;
              perspective: 1000px;
      right: 0px;
      bottom: 0px;
      -webkit-transform: translate(-50%, -50%);
              transform: translate(-50%, -50%);
    }

    .cube {
      /*
      width: 100%;
      height: 100%;
      */
      width: 0%; /* 大角度旋转 */
      position: absolute;
      -webkit-transform-style: preserve-3d;
      transform-style: preserve-3d;
      -webkit-transform: rotateX(-15deg) rotateY(-20deg) translateZ(-100px);
      transform: rotateX(-15deg) rotateY(-20deg) translateZ(-100px);
      -webkit-transform-origin: center center -100px;
      transform-origin: center center -100px;
      -webkit-animation: around 5s cubic-bezier(0.94, -0.6, 0.45, 1.31) infinite;
      animation: around 5s cubic-bezier(0.94, -0.6, 0.45, 1.31) infinite;
    }
    .cube div {
      width: 50px;
      height: 50px;
      display: block;
      margin: 0;
      position: absolute;
    }
    .cube div a {
      color: white;
      font-size: 12px;
      text-decoration: none;
      text-align: center;
      position: fixed;
      top: 50%;
      left: 45%;
      -webkit-transform: translate(-50%, -50%);
              transform: translate(-50%, -50%);
    }
    .cube .front {
      -webkit-transform: rotateY(0deg) translateZ(25px);
              transform: rotateY(0deg) translateZ(25px);
      background-color: rgba(0, 191, 255, 0.7);
      border: 1px solid rgba(0, 191, 255, 0.7);
    }
    .cube .back {
      -webkit-transform: rotateX(180deg) translateZ(25px);
              transform: rotateX(180deg) translateZ(25px);
      background-color: rgba(124, 252, 0, 0.7);
      border: 1px solid rgba(124, 252, 0, 0.7);
    }
    .cube .left {
      -webkit-transform: rotateY(-90deg) translateZ(25px);
              transform: rotateY(-90deg) translateZ(25px);
      background-color: rgba(255, 215, 0, 0.7);
      border: 1px solid rgba(255, 215, 0, 0.7);
    }
    .cube .right {
      -webkit-transform: rotateY(90deg) translateZ(25px);
              transform: rotateY(90deg) translateZ(25px);
      background-color: rgba(255, 69, 0, 0.7);
      border: 1px solid rgba(255, 69, 0, 0.7);
    }
    .cube .top {
      -webkit-transform: rotateX(90deg) translateZ(25px);
              transform: rotateX(90deg) translateZ(25px);
      background-color: rgba(255, 0, 157, 0.7);
      border: 1px solid rgba(255, 0, 157, 0.7);
    }
    .cube .bottom {
      -webkit-transform: rotateX(-90deg) translateZ(25px);
              transform: rotateX(-90deg) translateZ(25px);
      background-color: rgba(184, 111, 220, 0.7);
      border: 1px solid rgba(184, 111, 220, 0.7);
    }

     @-webkit-keyframes around {
      100% {
        -webkit-transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
                transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
      }
    }

    @keyframes around {
      100% {
        -webkit-transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
        transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
      }
    }
</style>

<div class="cube_container">
	  <div class="cube">
	    <div class="front"><a onclick="back2top()" rel="nofollow"> 欢迎光临 </a></div>
	    <div class="back"><a onclick="back2top()" rel="nofollow"> ❤️ </a></div>
	    <div class="right"><a onclick="back2top()" rel="nofollow"> 孤桜懶契 </a></div>
	    <div class="left"><a onclick="back2top()" role="button" rel="nofollow"> 请多关照 </a></div>
	    <div class="top"><a href="https://gylq.gitee.io/gylq-navigation/" target="_blank" rel="nofollow"> ❤️ </a></div>
	    <div class="bottom"><a href="https://gylq.gitee.io/gylq-navigation/" target="_blank" rel="nofollow"> ❤️ </a></div>
	  </div>
</div>

<script>

  function back2top(){
    $('html, body').animate({scrollTop: 0}, 500);
  }

</script>

   


<!-- Console 输出第三方个性化字体 -->

  <script async type="text/javascript" src="/figlet/fetch.min.js"></script>
  <script type="text/javascript" src="/figlet/figlet.js"></script>
  <script type="text/javascript">

      figlet.defaults({fontPath: "/figlet/fonts"});
      figlet("Welcome To 孤桜懶契", "Big Money-ne", function(err, text) {
          if (err) {
              console.log("something went wrong...");
              console.dir(err);
              return;
          }
          console.log(text);
      });
  </script>


  <!-- Console 输出自定义字体 -->
  
    <script async type="text/javascript">
        var text = "Welcome To Leaface";
        var date = '2022-11-03';
        console.log("%c " + text, "font-size:100px;color:white;border-radius:20px;height:200px; background:-webkit-linear-gradient(yellow,orange,red,green,blue,purple);text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);");
        console.info('\n' + ' %c Leafae Site %c https://www.liaofuzhan.com ' + '\n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;');
        console.info('\n' + ' %c Leafae QQ %c 793458585 ' + '\n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;');
        console.info('\n' + ' %c Leafae Wechat %c leaface ' + '\n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;');
       // console.log("%c Time: " + date, "font-size:100px;white:"+fcolor+";border-radius:20px;height:200px; background:-webkit-linear-gradient(yellow,orange,red,green,blue,purple);text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);  background-image: linear-gradient(to right, orangered, orange, gold, lightgreen, cyan, dodgerblue, mediumpurple, hotpink, orangered);");
       // console.log("%c .", "padding:300px 600px;line-height:10px;background:url(https://s2.ax1x.com/2019/10/17/KkoAJJ.md.png) no-repeat;");
    </script>
  


  <!-- 看板娘 -->
  
      <script async src="/live2d-widget/autoload.js"></script>
  

  
  

  <!-- 代码块复制功能 -->
  <script async type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script async type="text/javascript" src="/js/src/clipboard-use.js"></script>

  <!--share.js-->
  <link async rel="stylesheet" href="/sharejs/css/share.min.css">
  <script async src="/sharejs/js/social-share.min.js"></script>

  <!-- 模仿知乎卡片样式链接、崩溃欺骗特效 -->
  <script async type="text/javascript" src="/js/src/linkcard.js"></script>

  <!--崩溃欺骗 放在js文件最后-->
  <!--
  <script type="text/javascript" src="/js/src/crash_cheat.js"></script>
  -->

 
    <script src="https://myhkw.cn/api/player/159368326389" id="myhk" key="159368326389" m="1"></script>
 


</body>
</html>
